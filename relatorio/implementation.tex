\chapter{Implementação}

\section{Spacecheck}

\subsection{Encontrar os diretórios}

Para conseguir gerir e monitorizar o espaço ocupado em disco dentro de
diretórios é primeiro essencial saber quais são os diretórios a ser usados.

Usando os argumentos passados ao script com os diretórios a serem pesquisados,
descobrimos os seus sub-diretórios todos através do comando
\bashinline{find} da seguinte maneira:
\begin{listing}[H]
  \begin{minted}{bash}
    find "${DIRS_TO_SEARCH[@]}" -type d -print0 2>/dev/null
  \end{minted}
\end{listing}
Procuramos dentro dos diretórios passados todos os seus sub-diretórios
(\bashinline{-type d}). Todos os erros não nos são relevantes por isso
não os imprimimos.

É de notar que os caminhos dos diretórios são impressos separados por \Verb|'\0'| e não por \Verb|'\n'| como normalmente seriam.
A razão para fazer desta maneira será explicada mais 
tarde quanto começarmos a iterar sobre eles.

\subsection{Escolher os ficheiros}

Após obter os diretórios todos é importante conseguir trabalhar sobre cada um deles, para isso usamos o \bashinline{while read} da seguinte maneira:

\begin{listing}[H]
  \begin{minted}{bash}
    while IFS= read -r -d $'\0' path; do
      // ...
    done
  \end{minted}
\end{listing}

Aqui colocamos o \bashinline{IFS} nulo para não separar por espaços,
sendo que diretórios podem conte-los e não queremos cortá-los. O \bashinline|-d $'\0'| tem um
papel importante, visto que como nós estamos a passar uma string de caminhos
separados por \Verb|'\0'| é essencial neste passo mudar o delimitador do
\bashinline{while read} para o \Verb|'\0'|.

Com isto podemos começar a procurar os ficheiros a serem usados no cálculo do
tamanho através de outro \bashinline{find}, contudo desta vez ele terá
algumas diferenças.

\begin{listing}[H]
  \begin{minted}{bash}
    find "$path" "${FIND_OPTS[@]}" -type f -print0  2>/dev/null
  \end{minted}
\end{listing}

O \bashinline{path} vem do loop e o \bashinline|${FIND_OPTS[@]}|
será falado no processamento de argumentos (\ref{sec:args}), mas contém as opções relevantes
para a pesquisa de acordo com os argumentos passados pelo utilizador.\label{sec:find_opts}

Além do array de opções a principal diferença deste \bashinline{find}
para o outro é que este apenas procura por ficheiros (\Verb|type -f|) mas tal como no outro imprime
os caminhos separados por \Verb|'\0'|.

\subsection{Calcular o tamanho de cada diretório}

Uma vez que já temos uma lista com todos os ficheiros referentes a um
diretório, o último passo que falta é calcular o tamanho de todos ficheiros.
Felizmente para nós o comando \bashinline{du} consegue facilmente fazer
isso utilizando o seguinte comando.

\begin{listing}[H]
  \begin{minted}{bash}
    du -b --files0-from=- -cs 2>/dev/null | cut -f1 | tail -n1
  \end{minted}
\end{listing}

O commando \bashinline{du -b} serve para obter o espaço utilizado pelos
ficheiros em bytes. O argumento \bashinline{--files0-from=-} é necessário aqui visto que serve para ler caminhos do \Verb|stdin| separados por \Verb|'\0'|, que é como nós formatámos os dados no passo anterior com o
\bashinline{-print0} no \bashinline{find}. Por fim, usamos a opção
\bashinline{-cs} na qual o \Verb|c| mostra a soma dos tamanhos de todos os ficheiros e o \Verb|s| serve para evitar repetições
(o seu único propósito é eficiência).

De seguida usamos o comando \bashinline{cut -f1} para obter tudo até o
primeiro \Verb|'\t'| e, por fim, damos \bashinline{tail -n1} para extrair
só a última linha, que é a que contém o valor total.

Se ocorrer algum erro no \bashinline{du} o tamanho do diretório será substituido por \Verb|NA|.

\subsection{Processamento de argumentos}\label{sec:args}

Para o processamento dos argumentos usamos o comando \bashinline{getopts} com o padrão \bashinline{":hran:d:s:l:"}.

A opção \Verb|-h| imprime a seguinte mensagem:

\begin{listing}[H]
  \begin{minted}{bash}
    Usage: ./spacecheck.sh [options] [dir...]

    Options:
      -h:          Shows this message
      -n PATTERN:  Filter files by name according to the pattern
      -d N:        Filter files by date of modification
      -s N:        Filter files by file size
      -r:          Print in reverse order
      -a:          Order by file name
      -l N:        Only show up to N lines
  \end{minted}
\end{listing}

A opção \Verb|-n| está implementada da seguinte forma:

\begin{listing}[H]
\begin{minted}{bash}
pattern="$OPTARG"
FIND_OPTS+=("-regextype" "posix-extended" "-regex" "^.*/$pattern$")
\end{minted}
\end{listing}

Começamos por escolher o tipo de expressão regular que queremos usar, neste caso \Verb|posix-extended|.
De seguida passamos uma expressão regular que processa tudo depois da última \Verb|'/'| de acordo com o padrão passado pelo utilizador.
As opções do \Verb|FIND_OPTS| são usadas pelo \Verb|find| falado anteriormente (\ref{sec:find_opts}).

A opção \Verb|-d| está implementada da seguinte forma:

\begin{listing}[H]
\begin{minted}{bash}
			data="$OPTARG"
			timestamp="@$(date -d "$data" +%s)"
			FIND_OPTS+=("-newermt" "$timestamp")
\end{minted}
\end{listing}

A opção \Verb|-newermt| faz com que o \Verb|find| apenas procure por ficheiros com data de modificação mais recente ou igual à data passada. Esta é convertida para unix time através do comando \bashinline{date -d "$data" +%s}, e é assim que é passada ao \Verb|find|.

Quanto à opção \Verb|-s| a forma como é implementada é semelhante às outras:

\begin{listing}[H]
  \begin{minted}{bash}
    tamanho="$OPTARG"
    if [[ "${tamanho:0-1}" =~ ^[0-9]+$ ]]; then
      tamanho+="c"
    fi
    if [[ "${tamanho:0:1}" =~ ^[0-9]+$ ]]; then
      tamanho="+$tamanho"
    fi
    FIND_OPTS+=("-size" "$tamanho")
  \end{minted}
\end{listing}

O primeiro \Verb|if| verifica se o último caráter é um número e caso seja adiciona um \Verb|'c'| no fim da string.
O \Verb|'c'| é para dizer que o tamanho está especificado em bytes.

O segundo \Verb|if| verifica se o primeiro caráter é um número e caso seja adiciona um \Verb|'+'| no inicio da string.
O \Verb|'+'| é para especificar o tamanho dos ficheiros tem de ser maior do que o tamanho passado.

A opção \Verb|-r| está implementada de uma forma diferente sendo que no processamento dos argumentos apenas faz \bashinline{REVERSE_SORT=true}

A opção \Verb|-a| está implementada da mesma forma que o \Verb|-r| sendo que apenas faz \bashinline{NAME_SORT=true}

Por fim a opção \Verb|-l| adiciona a um array \Verb|HEAD_OPTS| a opção do \Verb|head| com o número de linhas passado pelo utilizador.

\begin{listing}[H]
  \begin{minted}{bash}
      linhas="$OPTARG"
      HEAD_OPTS+=("-n" "$linhas")
  \end{minted}
\end{listing}

\subsection{Ordenar o output}\label{sec:sort}

Para ordenar o output começamos por criar um array com todas as opções que serão utilizadas para no \Verb|sort|:

\begin{listing}[H]
  \begin{minted}{bash}
    NAME_REVERSE_SUFFIX=$([ "$REVERSE_SORT" = false ] && echo "" || echo "r")
    SIZE_REVERSE_SUFFIX=$([ "$REVERSE_SORT" = true ] && echo "" || echo "r")

    SORT_BY_NAME=("-k" "2$NAME_REVERSE_SUFFIX")
    SORT_BY_SIZE=("-k" "1,1n$SIZE_REVERSE_SUFFIX")

    if [ "$NAME_SORT" = true ] ; then
      SORT_OPTS+=( "${SORT_BY_NAME[@]}" "${SORT_BY_SIZE[@]}" )
    else
      SORT_OPTS+=( "${SORT_BY_SIZE[@]}" "${SORT_BY_NAME[@]}" )
    fi
  \end{minted}
\end{listing}

O primeiro passo é saber se a ordem tem de ser inversa ou não.
Para isso criamos duas variáveis \Verb|NAME_REVERSE_SUFFIX| e \Verb|SIZE_REVERSE_SUFFIX| que contêm o sufixo \Verb|r| ou são uma string vazia.
No caso do \Verb|SIZE_REVERSE_SUFFIX| ele por padrão vai ter o sufixo \Verb|r| visto que é a ordem pretendida quando não se passam argumentos ao script.

Após isso criamos dois arrays \Verb|SORT_BY_NAME| e \Verb|SORT_BY_SIZE| que contêm as opções para ordenar por nome e por tamanho respetivamente.

A opção \Verb|-k| do sort serve para especificar as colunas a serem usadas para ordenar.
No primeiro array a coluna escolhida é a segunda e é concatenada com o sufixo \Verb|NAME_REVERSE_SUFFIX| que é \Verb|r| caso a ordem seja inversa e vazio caso não seja.
De forma semelhante no segundo array a coluna escolhida é a primeira com a opção \Verb|n| que serve para comparar numericamente e é concatenada com o sufixo \Verb|SIZE_REVERSE_SUFFIX| que é vazio caso a ordem seja inversa e \Verb|'r'| caso não seja.

É importante notar que o -k escolhe em que coluna começar e em qual acabar, sendo o padrão começar na coluna escolhida e acabar na última.
Por isso aqui no primeiro array apenas é especificada a coluna 2 e no segundo é especificada a coluna de inicio 1 e a de fim também 1.

Após isso é verificado se a ordem é por nome ou por tamanho e adicionado ao array \Verb|SORT_OPTS| as opções respetivas pela ordem correta.

Por fim, para ordenar o output é usado o command \bashinline{sort "${SORT_OPTS[@]}"} no fim do \Verb|while|.

\subsection{Escolher o número de linhas}\label{sec:head}

O último passo é escolher o número de linhas a serem impressas.
Como já temos o array \Verb|HEAD_OPTS| basta passar o output ordenado ao seguinte comando:

\begin{listing}[H]
  \begin{minted}{bash}
    [ "${#HEAD_OPTS[@]}" -lt 1 ] && cat || head "${HEAD_OPTS[@]}"
  \end{minted}
\end{listing}

Se o número de opções for menor que 1 então imprime tudo, caso contrário imprime apenas as primeiras linhas.

\section{Spacerate}

\subsection{Extrair os dados para dicionários}

O primeiro e principal passo para começar a comparar os diretórios é colocá-los numa estrutura de dados que seja fácil de manipular.
Para isso começamos por declarar dois dicionários, um para cada ficheiro, mas também será criado um terceiro dicionário que será usado para obter todos os diretórios dos dois ficheiros, sem repetições.

\begin{listing}[H]
  \begin{minted}{bash}
    declare -A SPACECHECK_NEWEST
    declare -A SPACECHECK_OLDEST

    declare -A DIRECTORIES
  \end{minted}
\end{listing}

Para facilitar a leitura do código chamamos ao primeiro ficheiro \Verb|NEWESTFILE| e ao segundo \Verb|OLDESTFILE|.

Após isso são feitos dois \bashinline{while read} um para cada ficheiro passado como argumento ao script.

\begin{listing}[H]
  \begin{minted}{bash}
    while IFS=$'\n' read -r line; do
      # ...
    done < <(tail -n +2 -- "$NEWESTFILE")
  \end{minted}
\end{listing}

O mesmo faz-se para o \Verb|OLDESTFILE|.

O \bashinline{tail -n +2} serve para ignorar a primeira linha do ficheiro, que contém o header.
DOUBLE CHECK THIS
O \bashinline|IFS=$'\n'| serve para separar as linhas por \Verb|'\n'| e não por espaços.

Dentro do loop é feito o parsing de cada linha do ficheiro da seguinte maneira:

\begin{listing}[H]
  \begin{minted}{bash}
      size=$(echo "$line" | cut -f1)
      name=$(echo "$line" | cut -f2-)
      SPACECHECK_NEWEST["$name"]="$size"
      DIRECTORIES["$name"]=1
  \end{minted}
\end{listing}

Como as colunas estão separadas por \Verb|'\t'| usamos o \bashinline{cut -f1} para obter a primeira coluna e o \bashinline{cut -f2-} para obter todas as outras.
Após isso é adicionado ao dicionário \Verb|SPACECHECK_NEWEST| o nome do ficheiro como chave e o tamanho como valor.
Ao mesmo tempo também adicionamos ao dicionário \Verb|DIRECTORIES| o nome do ficheiro como chave e o valor 1, que como é um dicionário não repete as chaves, logo vamos obter uma lista com todos os diretórios dos dois ficheiros.

\subsection{Obter as diferenças entre cada ficheiro}

Agora que já temos os dados guardados em dicionários podemos começar a comparar os dois ficheiros.
Para isso começamos por iterar sobre os diretórios.

\begin{listing}[H]
  \begin{minted}{bash}
    for key in "${!DIRECTORIES[@]}"; do
      # ...
    done
  \end{minted}
\end{listing}

Para simplificar o código guardamos os tamanhos dos diretórios em variáveis.

\begin{listing}[H]
  \begin{minted}{bash}
      old_size="${SPACECHECK_OLDEST[$key]}"
      new_size="${SPACECHECK_NEWEST[$key]}"
  \end{minted}
\end{listing}

Caso o \Verb|old_size| seja vazio significa que o diretório não existe no ficheiro antigo mas existe no novo, logo não precisamos de calcular a diferença e baste adicionar \Verb|NEW| no fim.

\begin{listing}[H]
  \begin{minted}{bash}
      if [ -z "$old_size" ]; then
        echo -e "$new_size\t$key\tNEW"
      ...
  \end{minted}
\end{listing}

Caso o \Verb|new_size| seja vazio significa que o diretório não existe no ficheiro novo mas existe no antigo, logo não precisamos de calcular a diferença e baste adicionar \Verb|REMOVED| no fim e fazer o inverso do tamanho, ou seja, adicionar um \Verb|'-'| no inicio do size.

\begin{listing}[H]
  \begin{minted}{bash}
    ...
    elif [ -z "$new_size" ]; then
      if [ "$old_size" == "0" ] || [ "$old_size" == "NA" ]; then
        display_size="$old_size"
      else
        display_size="-$old_size"
      fi

      echo -e "$display_size\t$key\tREMOVED"
    ...
  \end{minted}
\end{listing}

Aqui para não imprimir \Verb|"-0"| ou \Verb|"-NA"| nos casos em que o \Verb|old_size| é \Verb|0| ou \Verb|NA| criamos uma variável \Verb|display_size| que vai ser usada para imprimir o tamanho.

Caso algum dos dois tamanhos seja \Verb|NA| o resultado impresso será \Verb|NA|.

\begin{listing}[H]
  \begin{minted}{bash}
    ...
    elif [ "$old_size" == "NA" ] || [ "$new_size" == "NA" ]; then
      echo -e "NA\t$key"
    ...
  \end{minted}
\end{listing}

Por fim, se os dois tamanhos existirem e não forem \Verb|NA| então calculamos a diferença entre eles e imprimimos o resultado.

\begin{listing}[H]
  \begin{minted}{bash}
    else
      diff=$((new_size - old_size))
      echo -e "$diff\t$key"
    fi
    ...
  \end{minted}
\end{listing}

\subsection{Processamento de argumentos}

Para o processamento dos argumentos usamos o comando \bashinline{getopts} com o padrão \bashinline{":hral:"}.

A opção \Verb|-h| imprime a seguinte mensagem:

\begin{listing}[H]
  \begin{minted}{bash}
    Usage: spacerate.sh [options] <new> <old>

    Options:
      -h:          Shows this message
      -r:          Print in reverse order
      -a:          Order by file name
      -l N:        Only show up to N lines
  \end{minted}
\end{listing}

Em relação ao processamento dos argumentos é feito da mesma forma que no \bashinline{spacecheck.sh} mas sem os argumentos que não se aplicam. (\ref{sec:args})

\subsection{Ordenar o output}

Ver \ref{sec:sort}

\subsection{Escolher o número de linhas}

Ver \ref{sec:head}


\section{Conclusão}

Todos os argumentos e ficheiros são validados e caso não sejam válidos é impressa uma mensagem de erro e o programa termina.

Além disso são verificados casos especiais como diretórios com um \Verb|'-'| no inicio.

\begin{listing}[H]
  \begin{minted}{bash}
    for dir in "$@"; do
      if [ ! -d "$dir" ]; then
        1>&2 echo "ERROR: \"$dir\" does not exist"
      fi
      case "$dir" in
        -*)
          if [ ! -d "$dir" ]; then
            1>&2 echo "+note: did you mean to pass an argument?"
            1>&2 echo "       all arguments must precede the directory paths"
          fi
          # Add `./` to directories beginning with a dash (`-`), so that find, doesn't
          # mistake them, for functions.
          DIRS_TO_SEARCH+=("./$dir");;
        *)
          DIRS_TO_SEARCH+=("$dir");;
      esac
    done
  \end{minted}
\end{listing}
