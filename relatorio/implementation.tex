\chapter{Implementação}

\section{Spacecheck}

\subsection{Encontrar os diretórios}

Para conseguir gerir e monitorizar o espaço ocupado em disco dentro de
diretórios é primeiro essencial saber quais são os diretórios a ser usados.

Usando os argumentos passados ao script com os diretórios a serem pesquisados,
descobrimos os seus sub-diretórios todos atraves do comando
\mintinline{bash}{find} da seguinte maneira:
\begin{listing}[H]
  \begin{minted}{bash}
    find "$@" -type d -print0 2>/dev/null
  \end{minted}
\end{listing}
Procuramos dentro dos diretórios passados todos os seus sub-diretórios
(\mintinline{bash}{-type d}). Todos os erros não nos são relevantes por isso
não os imprimimos. A forma como os caminhos dos diretórios são impressos também
é relevante sendo que eles acabam com \Verb|'\0'| e não \Verb|'\n'| como normalmente
seriam.

O motivo para fazer a impressão dos caminhos desta maneira será evidente mais
tarde quanto começarmos a iterar sobre eles.

\subsection{Escolher os ficheiros}

Após obter todos os sub-diretórios dos diretórios passados é importante
conseguir trabalhar sobre cada um deles, para isso usamos o
\mintinline{bash}{while read} da seguinte maneira:

\mintinline{bash}{find} da seguinte maneira:
\begin{listing}[H]
  \begin{minted}{bash}
    while IFS= read -r -d $'\0' path; do
      // ...
    done
  \end{minted}
\end{listing}

Aqui colocamos o \mintinline{bash}{IFS} nulo para não separar por espaços,
sendo que cada diretório pode conte-los. O \mintinline{bash}{-d $'\0'} tem um
papel importante, visto que como nós estamos a passar uma string de paths
separados por \Verb|'\0'| é essencial neste passo mudar o delimitador do
\mintinline{bash}{while read} para o \Verb|'\0'|.

Com isto podemos começar a procurar os ficheiros a serem usados no calculo do
tamanho usando outro \mintinline{bash}{find}, contudo desta vez ele terá
algumas diferenças grandes.

\begin{listing}[H]
  \begin{minted}{bash}
    find "$path" "${FIND_OPTS[@]}" -type f -print0  2>/dev/null
  \end{minted}
\end{listing}

O \mintinline{bash}{path} vem do loop e o \mintinline{bash}{${FIND_OPTS[@]}}
será falado no processamento de argumentos, mas contém as opções relevantes
para a pesquisa de acordo com os argumentos passados pelo utilizador.

Além do array de opções a principal diferença deste \mintinline{bash}{find}
para o outro é que este apenas procura por ficheiros, e como no outro imprime
os caminhos separados por \Verb|'\0'|.

\subsection{Calcular o tamanho de cada diretório}

Uma vez que já temos uma lista com todos os ficheiros referentes a um
diretório, o ultimo passo que falta é calcular o tamanho de todos ficheiros.
Felizmente para nós o comando \mintinline{bash}{du} consegue facilmente fazer
isso para nós utilizando o seguinte comando.

\begin{listing}[H]
  \begin{minted}{bash}
    du -b --files0-from=- -cs 2>/dev/null | cut -f1 | tail -n1
  \end{minted}
\end{listing}

O commando \mintinline{bash}{du -b} serve para obter o espaço utilizado pelos
ficheiros em bytes. O argumento \mintinline{bash}{--files0-from=-} é bastante
importante aqui sendo que o seu significado é ler do \Verb|stdin| delimitado
por \Verb|'\0'|, que é como nós formatamos os dados no passo anterior com o
\mintinline{bash}{-print0} no \mintinline{bash}{find}. Por fim, usamos a opção
\mintinline{bash}{-cs} na qual o \Verb|c| mostra o total do tamanho dos
ficheiros passados (ou seja a soma) e o \Verb|s| serve para evitar repetições
(o seu unico proposito é eficiencia).

De seguida uso o comando \mintinline{bash}{cut -f1} para obter tudo até o
primeiro \Verb|'\t'| e por fim damos \mintinline{bash}{tail -n1} para extrair
so a ultima linha, que é a que contem o valor total.

\subsection{Processamento de argumentos}

\subsection{Ordenar o output}

\subsection{Escolher o número de linhas}

\section{Spacerate}

\subsection{Extrair os dados para um dicionário}

\subsection{Obter uma lista de todos os caminhos}

\subsection{Obter as diferenças entre cada ficheiro}

