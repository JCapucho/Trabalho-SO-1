\chapter{Implementação}

\section{Introdução}

Neste trabalho foi nos pedido que críassemos dois scripts \emph{Bash}:
\Verb|spacecheck.sh| e \Verb|spacerate.sh|, cada um destes desempharia uma
função diferente mas complementares.

O script \Verb|spacecheck.sh| é responsável por produzir um relatório que
detalha o espaço ocupado por um diretório e como está distribuído pelos seus
subdiretórios, com opções extra para controlar quais ficheiros contam para esta
métrica.

Os resultados da execução poderiam depois ser comparados com recurso ao script
\Verb|spacerate.sh|, este calcularia a diferença entre os resultados e
apresentaria ao utilizador como o tamanho dos diretórios variou e se foram
introduzidos diretórios novos ou removidos.

Nesta secção vamos detalhar como implementamos os nossos scripts, incluindo não
só como funcionam mas também a lógica por detrás das nossas decisões para os
construir desta maneira.

Os scripts possuem uma parte semelhante aos dois significativa (por exemplo, o
processamento de argumentos e o ordenamento de resultados) como tal iremos
começar por discutir as partes específicas a cada programa e de seguida
abordaremos as partes comuns.

\cprotect\section{\Verb|spacecheck.sh|}

O script \Verb|spacecheck.sh| como já foi referido mostra o espaço ocupado por
um diretório e todos os seus sub diretórios, possuindo opções para filtrar os
ficheiros a usar no cálculo do espaço ocupado.

Podemos então dividir a implementação em três grandes problemas a resolver:

\begin{enumerate}
	\item Encontrar os diretórios e subdiretórios
	\item Escolher os ficheiros que contam
	\item Calcular o tamanho do diretório
\end{enumerate}

Vamos então começar por explorar cada um destes problemas e como foram resolvidos.

\subsection{Encontrar os diretórios}\label{sec:implementation_find_dirs}

O primeiro passo então é descobrir todos os diretórios e subdiretórios que terão
de ser considerados pelo script.

O comando \Verb|find| é ideal para esta situação, este permite descobrir
recursivamente os ficheiros e subdiretórios de vários diretórios que são
passados como argumentos. Além disso conseguimos filtrar os resultados para só
obter diretórios. Logo uma primeira versão para resolver este problema seria
parecida com algo semelhante ao código
\ref{code:implementation_first_subdir_find}.

\begin{listing}[H]
	\centering
	\begin{minted}{bash}
    find "$@" -type d
  \end{minted}
	\caption{Exemplo de como obter os subdiretórios}
	\label{code:implementation_first_subdir_find}
\end{listing}

Este código parece ser a solução ideal para o problema, e em alguns aspetos é,
por exemplo, esta primeira versão lida corretamente com argumentos que têm
espaços. Mas o problema desta solução não é o facto de funcionar mas o resultado
que produz.

Se por exemplo, executássemos este comando num diretório \Verb|test| que têm
dois subdiretórios \Verb|a| e \Verb|b|, obteríamos o seguinte resultado:

\begin{listing}[H]
	\centering
	\begin{minted}{text}
    test
    test/a
    test/b
  \end{minted}
	\cprotect\caption{Exemplo do resutlado obtido pelo \Verb|find|}
\end{listing}

Como podemos ver os resultados vêm separados por linhas novas (\Verb|\n|), isto
para a vasta maioria dos casos funciona, no entanto a norma \emph{POSIX} define
que um nome de ficheiro/diretório pode ser constituído por qualquer byte com a
exceção do byte nulo (\bashinline|\0|) e da barra (\bashinline|/|)
\cite[60]{posix}.

Isto implica que \bashinline|a\nd| é um nome completamente válido para um diretório,
se executarmos o mesmo comando no diretório \Verb|test| onde agora existe este
subdiretório, obtemos o seguinte resultado.

\begin{listing}[H]
	\centering
	\begin{minted}{text}
    test/a
    d
    test/a
    test/b
  \end{minted}
	\caption{Resultado obtido com um diretório que contêm uma linha nova}
\end{listing}

Apesar disto ser uma situação rara é uma possibilidade e como tal temos de a
acautelar no nosso programa, mas já vimos que o caminho não pode conter bytes
nulos e o \Verb|find| contêm uma opção \Verb|-print0| que invês de separar os
resultados com uma linha nova, vai separar com o byte nulo \cite{find_man}.

Chegamos assim então a segunda iteração do comando para obter os diretórios e
subdiretórios apresentado no código \ref{code:implementation_second_subdir_find}.

\begin{listing}[H]
	\centering
	\begin{minted}{bash}
    find "$@" -type d -print0
  \end{minted}
	\caption{Segundo iteração do comando para obter os subdiretórios}
	\label{code:implementation_second_subdir_find}
\end{listing}

No entanto esta versão ainda tem um problema, como já vimos os diretórios podem
ter nomes pouco convencionais e se o nome começar com um híphen (\Verb|-|),
estes vão ser interpretados pelo \Verb|find| como opções. Para resolver isto
vamos ter de escapar manualmente todos os diretórios que começam com um híphen
\footnote{Mais a frente o mesmo problema terá de ser resolvido noutros comandos,
	estes ou aceitam um argumento especial \Verb|--| que sinaliza o fim das opções,
	ou têm uma opção \Verb|-files0-from|. O primeiro não existe no \Verb|find|
	devido a ordem pouco convencional dos argumentos, o segundo existe em algumas
	versões do \Verb|find| mas é pouco comum, principalmente em distribuições que
	não são baseadas nas ferramentas GNU. Logo decidimos pela opção manual.}.

\begin{listing}[H]
	\centering
	\begin{minted}{bash}
    DIRS_TO_SEARCH=()

    for dir in "$@"; do
      if [ ! -d "$dir" ]; then
        1>&2 echo "ERROR: \"$dir\" does not exist"
      fi
      case "$dir" in
        -*)
          if [ ! -d "$dir" ]; then
            1>&2 echo "+note: did you mean to pass an argument?"
            1>&2 echo "       all arguments must precede the directory paths"
          fi
          # Add `./` to directories beginning with a dash (`-`), so that find
          # doesn't mistake them, for options.
          DIRS_TO_SEARCH+=("./$dir");;
        *)
          DIRS_TO_SEARCH+=("$dir");;
      esac
    done
  \end{minted}
	\caption{Implementação do escape de diretorias começadas por híphen}
	\label{code:implementation_escape_options_find}
\end{listing}

O código \ref{code:implementation_escape_options_find}, mostra a implementação
final para escapar os híphens no início do nome dos diretórios. Este código
ainda implementa mensagens de erro para diretórios que não existem e mensagens
de ajuda casos esses diretórios pareçam ser opções.

Finalmente, é apresentado no código \ref{code:implementation_final_subdir_find}
a implementação final do comando para obter os diretórios e subdiretórios.

\begin{listing}[H]
	\centering
	\begin{minted}{bash}
    find "${DIRS_TO_SEARCH[@]}" -type d -print0
  \end{minted}
	\caption{Iteração final do comando para obter os subdiretórios}
	\label{code:implementation_final_subdir_find}
\end{listing}

\subsection{Escolher os ficheiros}\label{sec:implementation_choosing_files}

Agora que já temos os diretórios é necessário selecionar todos os ficheiros que
pertencem a um dado diretório e passam nos filtros definidos pelo utilizador.

Assumindo que o diretório a procurar se encontra na variável \Verb|path|, podemos
adaptar o comando utilizado na secção anterior para procurar todos os ficheiros
num dado diretório.

\begin{listing}[H]
	\centering
	\begin{minted}{bash}
    find "$path" -type f -print0
  \end{minted}
	\caption{Comando para listar todos os ficheiros num diretório}
\end{listing}

No entanto, isto não é suficiente pois é necessário filtrar os ficheiros de
acordo com as opções indicadas pelo utilizador. Para tal é introduzido um array
novo \Verb|FIND_OPTS|, este irá conter opções a passar ao \Verb|find| de acordo
com as opções especificadas pelo utilizador para o \Verb|spacecheck.sh|.

Logo o comando final para obter apenas os ficheiros que satisfazem os filtros
será o seguinte.

\begin{listing}[H]
	\centering
	\begin{minted}{bash}
    find "$path" "${FIND_OPTS[@]}" -type f -print0
  \end{minted}
	\caption{Comando para filtrar os ficheiros num diretório}
\end{listing}

A maneira como são processados os argumentos é detalhada na secção
\ref{sec:implementation_arg_parsing}. Mas vamos analisar como as opções do
\Verb|spacecheck.sh| são convertidas nas opções do \Verb|find|.

O valor passado as opções está na variável \Verb|OPTARG|, mais uma vez isto será
falado em maior detalhe na secção de processamento de argumentos.

\subsubsection{Filtragem do nome de ficheiro}

Vamos começar por explorar como o programa lida com a filtragem do nome de
ficheiro utilizando \emph{regex}.

\begin{listing}[H]
	\centering
	\begin{minted}{bash}
    pattern="$OPTARG"
    FIND_OPTS+=("-regextype" "posix-extended" "-regex" "^.*/$pattern$")
  \end{minted}
	\cprotect\caption{Construção do filtro de \emph{regex} sobre o nome do ficheiro}
\end{listing}

Começamos por escolher o tipo de expressão regular que queremos usar, neste
caso \Verb|posix-extended|, isto é feito por uma questão de usabilidade pois o
tipo de \emph{regex} por defeito é o \Verb|findutils-default| que utiliza uma
sintaxe muito pouco convencional e não têm alguns dos operadores comuns
\cite{find_man} como a estrela (\Verb|*|) que espera zero ou mais ocurrências
da expressão.

De seguida é passada a expressão regular, no entanto esta não pode ser passada
diretamente e precisa de algum código extra a sua volta. Isto é necessário pois
a opção \Verb|-regex| não aplica o \emph{regex} ao nome do ficheiro mas sim ao
caminho todo. Como tal começamos por ancorar o \emph{regex} ao ínicio do caminho
(\Verb|^|) e consumimos todos os caracteres (\Verb|.*|) até a última barra
\footnote{O \emph{regex} consome até a última barra porque é \emph{greedy}, ou
	seja este não pára na primeira barra que encontrar mas vai sim tentar consumir
	o máximo possível desde que respeite o padrão.}
, a este ponto o \emph{regex} está no início do nome do ficheiro por isso
aplicamos o \emph{regex} do utilizador, finalmente ancoramos o \emph{regex} ao
fim (\Verb|$|) isto garante que o nome do ficheiro passa totalmente no
\emph{regex} do utilizador e não apenas parcialmente (por exemplo, se o
utilizador passar o \emph{regex} \Verb|abc| nós queremos apenas aceitar
ficheiros com o nome \Verb|abc|, mas se o regex não tivesse ancorado também
aceitaríamos \Verb|abcd| entre outros).

\subsubsection{Filtragem por data de modificação}

Outra opção a disposição do utilizador, é a filtragem por data de modificação,
esta encontra-se implementada da seguinte maneira.

\begin{listing}[H]
	\centering
	\begin{minted}{bash}
			data="$OPTARG"
			FIND_OPTS+=('!' "-newermt" "$data")
  \end{minted}
	\caption{Construção do filtro por data de modificação}
\end{listing}

A opção \Verb|-newermt| faz com que o \Verb|find| apenas procure por ficheiros
com data de modificação mais recente à data passada, nós queremos o contrário por
isso utilizamos a opção \Verb|!| que inverte o filtro que aparece a sua direita.

As datas são processadas do mesmo modo que são processadas pelo programa
\Verb|date| \cite{find_man}, logo não é necessário qualquer passo extra para
converter da descrição textual passada pelo utilizador para tempo máquina.

\subsubsection{Filtragem por tamanho de ficheiro}

O último filtro implementado permite ao utilizador definir um tamanho mínimo que
os ficheiros devem ter para serem contabilizados. A nossa implementação permite
além disto filtrar ficheiros que tenham menos que o tamanho passado e mais (mas
não exatamente igual) através do uso dos prefixos \Verb|-| e \Verb|+|
respetivamente.

\begin{listing}[H]
	\centering
	\begin{minted}{bash}
    tamanho="$OPTARG"
    if [[ "${tamanho:0-1}" =~ ^[0-9]+$ ]]; then
      tamanho+="c"
    fi
    if [[ "${tamanho:0:1}" =~ ^[0-9]+$ ]]; then
      FIND_OPTS+=("(" "-size" "$tamanho" "-o" "-size" "+$tamanho" ")")
    else
      FIND_OPTS+=("-size" "$tamanho")
    fi
  \end{minted}
	\caption{Construção do filtro por tamanho do ficheiro}
\end{listing}

O primeiro \Verb|if| verifica se o último caráter é um número e caso seja
adiciona um sufixo \Verb|c| ao tamanho, isto serve para o \Verb|find|
intrepertar o tamanho em bytes em vez de blocos, como é feito por omissão pelo
\Verb|find|. Este sufixo condicional permite ao utilizador escolher outra
unidade se desejar, bastando adicionar o sufixo correto.

No segundo \Verb|if| verificamos se o primeiro caráter é um número, se for o
script vai definir um filtro composto no \Verb|find| este é delineado por
parênteses, caso contrário o filtro \emph{ou} (\Verb|-o|) não se aplicaria só ao
segundo filtro mas ao resto dos filtros todos. O primeiro filtro \Verb|-size|
não tem nenhum prefixo logo o \Verb|find| procura por ficheiros com exatamente o
tamanho especificado, este é seguido de um \emph{ou} como já foi referido que é
complementado com outro filtro \Verb|-size| mas este utiliza um tamanho com o
prefixo \Verb|+| que apenas aceita ficheiros estritamente maiores que o tamanho.
Esta combinação é necessária para obter todos os ficheiros maiores ou iguais ao
tamanho mínimo.

Se o primeiro caráter não for um número, o script considera que o tamanho têm um
prefixo e passa diretamente ao \Verb|find|, podendo assim o utilizador procurar
por ficheiros maiores e menores (mas não iguais) ao tamanho com o prefixo
\Verb|+| e \Verb|-| respetivamente.

\subsection{Calcular o tamanho de cada diretório}
\label{sec:implementation_calculate_size}

Agora que já temos uma lista de todos os ficheiros pertencentes a um
diretório, falta-nos apenas calcular o tamanho de todos ficheiros.
Para este fim vamos utilizar o comando \bashinline{du} que permite calcular o
espaço ocupado de uma lista de ficheiros.

A nossa lista de ficheiros vêm separada por bytes nulos, logo invês de passar os
ficheiros diretamente, vamos ter de utilzar a opção \Verb|--files0-from|, esta
causa com que o \bashinline{du}, invês de ler a lista de ficheiros do
\emph{stdin} separada por linhas novas, vá ler a lista de ficheiros separada por
bytes nulos do ficheiro passado como valor da opção \cite{du_man}, nós utilizamos
o valor especial \Verb|-| que sinaliza que o ficheiro p \emph{stdin}, desta
maneira conseguimos ler do \emph{stdin} separado por bytes nulos.

O comando \bashinline{du} por defeito mostra o espaço ocupado por cada ficheiro
mas não um total, no entanto, se passarmos a opção \Verb|-c| este irá imprimir
na última linha um total correspodente a soma do tamanho de todos os ficheiros
\cite{du_man}.

A primeira versão do comando que foi utilizado é apresentada no código
\ref{code:implementation_first_size_calcultate}.

\begin{listing}[H]
	\centering
	\begin{minted}{bash}
    du -c --files0-from=- | tail -n1 | cut -f1
  \end{minted}
	\caption{Primeira iteração do comando para calcular o tamanho dos ficheiros}
	\label{code:implementation_first_size_calcultate}
\end{listing}

O comando baseia-se no \bashinline{du} com as opções discutidas em cima, o
resultado da sua execução é depois redirecionado para o \bashinline{tail} que
irá filtrar tudo com a exceção da última linha (\Verb|-n1|), que será mais uma
vez redirecionada desta vez para o \bashinline{cut} que irá retirar a primeira
coluna (\Verb|-f1|), esta corresponde ao valor do tamanho total.

Esta versão tinha apenas o problema que o \bashinline{du} por omissão conta o
número de blocos ocupados no disco pelo ficheiro, no entanto nós queremos o
número de bytes ocupados pelo conteúdo do ficheiro (e não o numero de bytes do
bloco no disco onde reside o ficheiro). Isto pode ser resolvido com a opção
\Verb|-b| que não só retorna o resultado em bytes mas também conta o tamanho do
conteúdo invés dos blocos ocupados pelo ficheiro \cite{du_man}.

\begin{listing}[H]
	\centering
	\begin{minted}{bash}
    du -cb --files0-from=- | tail -n1 | cut -f1
  \end{minted}
	\caption{Iteração final do comando para calcular o tamanho dos ficheiros}
	\label{code:implementation_final_size_calcultate}
\end{listing}

A versão do código \ref{code:implementation_final_size_calcultate} é a que foi
implementada no programa final, esta produz o total do conteúdo dos ficheiros em
bytes.

\subsection{Integração final}

Agora que já foram resolvidos todos os problemas individualmente resta apenas
integrá-los todos de maneira a conseguir produzir a lista de tamanho ocupado por
diretório.

O primeiro passo é integrar o código para encontrar diretórios desnvolvido na
secção \ref{sec:implementation_find_dirs} de modo a conseguir processar cada
diretório individualmente. Isto é feito com recurso a um loop
\bashinline{while read}.

\begin{listing}[H]
	\centering
	\begin{minted}{bash}
    find "${DIRS_TO_SEARCH[@]}" -type d -print0 2>/dev/null | \
    while IFS= read -r -d $'\0' path; do
      ...
    done
  \end{minted}
	\caption{Iteração sobre os diretórios encontrados}
\end{listing}

Os erros na procura dos diretórios não nos são relevantes, por isso o
\emph{stderr} (\emph{file descriptor} 2) é redirecionado para o
\Verb|/dev/null|.

O loop em si começa por atribuir a variavél \bashinline{IFS} o valor nulo, isto
é necessário para garantir que o \bashinline{read} não separa por espaços o
resultado nem consome espaços no final do resultado, os diretórios podem
conte-los e nós queremos preservá-los.

O \bashinline|-r| é necessário caso contrário o \bashinline{read} intrepertaria
as barras invertidas como \emph{escape sequences} \cite[3191-3193]{posix}, os
ficheiros podem conter barras invertidas e nós queremos o seu valor literal logo
precisamos de desativar este processamento.

A opção \bashinline|-d $'\0'| também têm um papel importante, visto que como
a lista de diretórios se encontra separada por bytes nulos (\Verb|'\0'|) é
essencial mudar o delimitador do \bashinline{read} (que por omissão é a linha
nova) para o byte nulo, a string é precedida de um dollar (\Verb|$|) pois esta
causa com que a \emph{Bash} processe a string com \emph{escape sequences}, caso
contrário o valor literal de barra invertida seguida de zero seria passado ao
\bashinline{read}.

De seguida é necessário juntar os comandos para escolher os ficheiros
(desenvolivdo na secção \ref{sec:implementation_choosing_files}) e calcular
o tamanho (desenvolivdo na secção \ref{sec:implementation_calculate_size}). O
resultado do primeiro pode ser redirecionado diretamente para o segundo visto
que este já foi adaptado para receber a lista de ficheiros separada por bytes
nulos.

\begin{listing}[H]
	\centering
	\begin{minted}{bash}
    size=$(find "$path" "${FIND_OPTS[@]}" -type f -print0  2>/dev/null | \
         du -cb --files0-from=- 2>/dev/null | \
         tail -n1 | cut -f1)
  \end{minted}
	\caption{Cálculo do tamanho total de um diretório}
\end{listing}

Mais uma vez as mensagens de erro são ignoradas, no entanto desta vez os erros
não são simplesmente ignorados, pois se algum tiver ocorrido (por exemplo,
devido a falta de permissões) o tamanho é suposto aparecer como \Verb|NA|.

\begin{listing}[H]
	\centering
	\begin{minted}{bash}
    size=$(find "$path" "${FIND_OPTS[@]}" -type f -print0  2>/dev/null | \
         du -cb --files0-from=- 2>/dev/null | \
         tail -n1 | cut -f1)

    if [ "$?" -ne 0 ]; then
      size="NA"
    fi
  \end{minted}
	\caption{Cálculo do tamanho total de um diretório (com deteção de erros)}
	\label{code:implementation_dir_size_NA}
\end{listing}

No código \ref{code:implementation_dir_size_NA} o código de retorno é
verificado e se este não for 0 (ocorreu um erro) o tamanho é substituido por
\Verb|NA|.

Normalmente a variavél \Verb|$?| apenas contêm o código de erro do último
comando executado, no entanto nós queremos o código de erro da \emph{pipeline}
toda, isto poderia ser feito verificando os códigos de erro no array
\Verb|PIPESTATUS|, no entanto isto requer escrever uma condição para cada
comando na \emph{pipeline} o que é menos que ideal.

Mas a \emph{Bash} pode ser configurada para devolver o código de erro da
\emph{pipeline} toda diretamente na variavél \Verb|$?|, isto é feito através da
opção \Verb|pipefail| \cite{bash_man}, esta pode ser ativada como é apresentado
no código \ref{code:implementation_pipefail}.

\begin{listing}[H]
	\centering
	\begin{minted}{bash}
    set -o pipefail
  \end{minted}
	\cprotect\caption{Ativação da opção \Verb|pipefail|}
	\label{code:implementation_pipefail}
\end{listing}

Finalmente, basta apenas juntar estas duas partes que produzimos até agora.

\begin{listing}[H]
	\centering
	\begin{minted}{bash}
    set -o pipefail

    find "${DIRS_TO_SEARCH[@]}" -type d -print0 2>/dev/null | \
    while IFS= read -r -d $'\0' path; do
      size=$(find "$path" "${FIND_OPTS[@]}" -type f -print0  2>/dev/null | \
           du -cb --files0-from=- 2>/dev/null | \
           tail -n1 | cut -f1)
      if [ "$?" -ne 0 ]; then
        size="NA"
      fi

      echo -e "$size\t$path"
    done
  \end{minted}
	\cprotect\caption{Implementação do algoritmo principal do \Verb|spacecheck.sh|}
\end{listing}

\subsection{Processamento de argumentos}\label{sec:implementation_arg_parsing}

Para o processamento dos argumentos usamos o comando \bashinline{getopts} com o padrão \bashinline{":hran:d:s:l:"}.

A opção \Verb|-h| imprime a seguinte mensagem:

\begin{listing}[H]
	\centering
	\begin{minted}{text}
    Usage: ./spacecheck.sh [options] [dir...]

    Options:
      -h:          Shows this message
      -n PATTERN:  Filter files by name according to the pattern
      -d N:        Filter files by date of modification
      -s N:        Filter files by file size
      -r:          Print in reverse order
      -a:          Order by file name
      -l N:        Only show up to N lines
  \end{minted}
\end{listing}

A opção \Verb|-r| está implementada de uma forma diferente sendo que no processamento dos argumentos apenas faz \bashinline{REVERSE_SORT=true}

A opção \Verb|-a| está implementada da mesma forma que o \Verb|-r| sendo que apenas faz \bashinline{NAME_SORT=true}

Por fim a opção \Verb|-l| adiciona a um array \Verb|HEAD_OPTS| a opção do \Verb|head| com o número de linhas passado pelo utilizador.

\begin{listing}[H]
	\centering
	\begin{minted}{bash}
      linhas="$OPTARG"
      HEAD_OPTS+=("-n" "$linhas")
  \end{minted}
\end{listing}

\subsection{Ordenar o output}\label{sec:implementation_sort}

Para ordenar o output começamos por criar um array com todas as opções que serão utilizadas para no \Verb|sort|:

\begin{listing}[H]
	\centering
	\begin{minted}{bash}
    NAME_REVERSE_SUFFIX=$([ "$REVERSE_SORT" = false ] && echo "" || echo "r")
    SIZE_REVERSE_SUFFIX=$([ "$REVERSE_SORT" = true ] && echo "" || echo "r")

    SORT_BY_NAME=("-k" "2$NAME_REVERSE_SUFFIX")
    SORT_BY_SIZE=("-k" "1,1n$SIZE_REVERSE_SUFFIX")

    if [ "$NAME_SORT" = true ] ; then
      SORT_OPTS+=( "${SORT_BY_NAME[@]}" "${SORT_BY_SIZE[@]}" )
    else
      SORT_OPTS+=( "${SORT_BY_SIZE[@]}" "${SORT_BY_NAME[@]}" )
    fi
  \end{minted}
\end{listing}

O primeiro passo é saber se a ordem tem de ser inversa ou não.
Para isso criamos duas variáveis \Verb|NAME_REVERSE_SUFFIX| e \Verb|SIZE_REVERSE_SUFFIX| que contêm o sufixo \Verb|r| ou são uma string vazia.
No caso do \Verb|SIZE_REVERSE_SUFFIX| ele por padrão vai ter o sufixo \Verb|r| visto que é a ordem pretendida quando não se passam argumentos ao script.

Após isso criamos dois arrays \Verb|SORT_BY_NAME| e \Verb|SORT_BY_SIZE| que contêm as opções para ordenar por nome e por tamanho respetivamente.

A opção \Verb|-k| do sort serve para especificar as colunas a serem usadas para ordenar.
No primeiro array a coluna escolhida é a segunda e é concatenada com o sufixo \Verb|NAME_REVERSE_SUFFIX| que é \Verb|r| caso a ordem seja inversa e vazio caso não seja.
De forma semelhante no segundo array a coluna escolhida é a primeira com a opção \Verb|n| que serve para comparar numericamente e é concatenada com o sufixo \Verb|SIZE_REVERSE_SUFFIX| que é vazio caso a ordem seja inversa e \Verb|'r'| caso não seja.

É importante notar que o -k escolhe em que coluna começar e em qual acabar, sendo o padrão começar na coluna escolhida e acabar na última.
Por isso aqui no primeiro array apenas é especificada a coluna 2 e no segundo é especificada a coluna de inicio 1 e a de fim também 1.

Após isso é verificado se a ordem é por nome ou por tamanho e adicionado ao array \Verb|SORT_OPTS| as opções respetivas pela ordem correta.

Por fim, para ordenar o output é usado o command \bashinline{sort "${SORT_OPTS[@]}"} no fim do \Verb|while|.

\subsection{Escolher o número de linhas}\label{sec:implementation_head}

O último passo é escolher o número de linhas a serem impressas.
Como já temos o array \Verb|HEAD_OPTS| basta passar o output ordenado ao seguinte comando:

\begin{listing}[H]
	\centering
	\begin{minted}{bash}
    [ "${#HEAD_OPTS[@]}" -lt 1 ] && cat || head "${HEAD_OPTS[@]}"
  \end{minted}
\end{listing}

Se o número de opções for menor que 1 então imprime tudo, caso contrário imprime apenas as primeiras linhas.

\section{Spacerate}

\subsection{Extrair os dados para dicionários}

O primeiro e principal passo para começar a comparar os diretórios é colocá-los numa estrutura de dados que seja fácil de manipular.
Para isso começamos por declarar dois dicionários, um para cada ficheiro, mas também será criado um terceiro dicionário que será usado para obter todos os diretórios dos dois ficheiros, sem repetições.

\begin{listing}[H]
	\centering
	\begin{minted}{bash}
    declare -A SPACECHECK_NEWEST
    declare -A SPACECHECK_OLDEST

    declare -A DIRECTORIES
  \end{minted}
\end{listing}

Para facilitar a leitura do código chamamos ao primeiro ficheiro \Verb|NEWESTFILE| e ao segundo \Verb|OLDESTFILE|.

Após isso são feitos dois \bashinline{while read} um para cada ficheiro passado como argumento ao script.

\begin{listing}[H]
	\centering
	\begin{minted}{bash}
    while IFS=$'\n' read -r line; do
      # ...
    done < <(tail -n +2 -- "$NEWESTFILE")
  \end{minted}
\end{listing}

O mesmo faz-se para o \Verb|OLDESTFILE|.

O \bashinline{tail -n +2} serve para ignorar a primeira linha do ficheiro, que contém o header.
DOUBLE CHECK THIS
O \bashinline|IFS=$'\n'| serve para separar as linhas por \Verb|'\n'| e não por espaços.

Dentro do loop é feito o parsing de cada linha do ficheiro da seguinte maneira:

\begin{listing}[H]
	\centering
	\begin{minted}{bash}
      size=$(echo "$line" | cut -f1)
      name=$(echo "$line" | cut -f2-)
      SPACECHECK_NEWEST["$name"]="$size"
      DIRECTORIES["$name"]=1
  \end{minted}
\end{listing}

Como as colunas estão separadas por \Verb|'\t'| usamos o \bashinline{cut -f1} para obter a primeira coluna e o \bashinline{cut -f2-} para obter todas as outras.
Após isso é adicionado ao dicionário \Verb|SPACECHECK_NEWEST| o nome do ficheiro como chave e o tamanho como valor.
Ao mesmo tempo também adicionamos ao dicionário \Verb|DIRECTORIES| o nome do ficheiro como chave e o valor 1, que como é um dicionário não repete as chaves, logo vamos obter uma lista com todos os diretórios dos dois ficheiros.

\subsection{Obter as diferenças entre cada ficheiro}

Agora que já temos os dados guardados em dicionários podemos começar a comparar os dois ficheiros.
Para isso começamos por iterar sobre os diretórios.

\begin{listing}[H]
	\centering
	\begin{minted}{bash}
    for key in "${!DIRECTORIES[@]}"; do
      # ...
    done
  \end{minted}
\end{listing}

Para simplificar o código guardamos os tamanhos dos diretórios em variáveis.

\begin{listing}[H]
	\centering
	\begin{minted}{bash}
      old_size="${SPACECHECK_OLDEST[$key]}"
      new_size="${SPACECHECK_NEWEST[$key]}"
  \end{minted}
\end{listing}

Caso o \Verb|old_size| seja vazio significa que o diretório não existe no ficheiro antigo mas existe no novo, logo não precisamos de calcular a diferença e baste adicionar \Verb|NEW| no fim.

\begin{listing}[H]
	\centering
	\begin{minted}{bash}
      if [ -z "$old_size" ]; then
        echo -e "$new_size\t$key\tNEW"
      ...
  \end{minted}
\end{listing}

Caso o \Verb|new_size| seja vazio significa que o diretório não existe no ficheiro novo mas existe no antigo, logo não precisamos de calcular a diferença e baste adicionar \Verb|REMOVED| no fim e fazer o inverso do tamanho, ou seja, adicionar um \Verb|'-'| no inicio do size.

\begin{listing}[H]
	\centering
	\begin{minted}{bash}
    ...
    elif [ -z "$new_size" ]; then
      if [ "$old_size" == "0" ] || [ "$old_size" == "NA" ]; then
        display_size="$old_size"
      else
        display_size="-$old_size"
      fi

      echo -e "$display_size\t$key\tREMOVED"
    ...
  \end{minted}
\end{listing}

Aqui para não imprimir \Verb|"-0"| ou \Verb|"-NA"| nos casos em que o \Verb|old_size| é \Verb|0| ou \Verb|NA| criamos uma variável \Verb|display_size| que vai ser usada para imprimir o tamanho.

Caso algum dos dois tamanhos seja \Verb|NA| o resultado impresso será \Verb|NA|.

\begin{listing}[H]
	\centering
	\begin{minted}{bash}
    ...
    elif [ "$old_size" == "NA" ] || [ "$new_size" == "NA" ]; then
      echo -e "NA\t$key"
    ...
  \end{minted}
\end{listing}

Por fim, se os dois tamanhos existirem e não forem \Verb|NA| então calculamos a diferença entre eles e imprimimos o resultado.

\begin{listing}[H]
	\centering
	\begin{minted}{bash}
    else
      diff=$((new_size - old_size))
      echo -e "$diff\t$key"
    fi
    ...
  \end{minted}
\end{listing}

\subsection{Processamento de argumentos}

Para o processamento dos argumentos usamos o comando \bashinline{getopts} com o padrão \bashinline{":hral:"}.

A opção \Verb|-h| imprime a seguinte mensagem:

\begin{listing}[H]
	\centering
	\begin{minted}{text}
    Usage: spacerate.sh [options] <new> <old>

    Options:
      -h:          Shows this message
      -r:          Print in reverse order
      -a:          Order by file name
      -l N:        Only show up to N lines
  \end{minted}
\end{listing}

Em relação ao processamento dos argumentos é feito da mesma forma que no \bashinline{spacecheck.sh} mas sem os argumentos que não se aplicam. (\ref{sec:implementation_arg_parsing})

\subsection{Ordenar o output}

Ver \ref{sec:implementation_sort}

\subsection{Escolher o número de linhas}

Ver \ref{sec:implementation_head}


\section{Conclusão}

Todos os argumentos e ficheiros são validados e caso não sejam válidos é impressa uma mensagem de erro e o programa termina.

Além disso são verificados casos especiais como diretórios com um \Verb|'-'| no inicio.

\begin{listing}[H]
	\centering
	\begin{minted}{bash}
    for dir in "$@"; do
      if [ ! -d "$dir" ]; then
        1>&2 echo "ERROR: \"$dir\" does not exist"
      fi
      case "$dir" in
        -*)
          if [ ! -d "$dir" ]; then
            1>&2 echo "+note: did you mean to pass an argument?"
            1>&2 echo "       all arguments must precede the directory paths"
          fi
          # Add `./` to directories beginning with a dash (`-`), so that find, doesn't
          # mistake them, for functions.
          DIRS_TO_SEARCH+=("./$dir");;
        *)
          DIRS_TO_SEARCH+=("$dir");;
      esac
    done
  \end{minted}
\end{listing}
