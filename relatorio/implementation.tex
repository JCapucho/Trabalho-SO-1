\chapter{Implementação}

\section{Spacecheck}

\subsection{Encontrar os diretórios}

Para conseguir gerir e monitorizar o espaço ocupado em disco dentro de
diretórios é primeiro essencial saber quais são os diretórios a ser usados.

Usando os argumentos passados ao script com os diretórios a serem pesquisados,
descobrimos os seus sub-diretórios todos atraves do comando
\mintinline{bash}{find} da seguinte maneira:
\begin{listing}[H]
  \begin{minted}{bash}
    find "$@" -type d -print0 2>/dev/null
  \end{minted}
\end{listing}
Procuramos dentro dos diretórios passados todos os seus sub-diretórios
(\mintinline{bash}{-type d}). Todos os erros não nos são relevantes por isso
não os imprimimos. A forma como os caminhos dos diretórios são impressos também
é relevante sendo que eles acabam com \Verb|'\0'| e não \Verb|'\n'| como normalmente
seriam.

O motivo para fazer a impressão dos caminhos desta maneira será evidente mais
tarde quanto começarmos a iterar sobre eles.

\subsection{Escolher os ficheiros}

Após obter todos os sub-diretórios dos diretórios passados é importante
conseguir trabalhar sobre cada um deles, para isso usamos o
\mintinline{bash}{while read} da seguinte maneira:

\mintinline{bash}{find} da seguinte maneira:
\begin{listing}[H]
  \begin{minted}{bash}
    while IFS= read -r -d $'\0' path; do
      // ...
    done
  \end{minted}
\end{listing}

Aqui colocamos o \mintinline{bash}{IFS} nulo para não separar por espaços,
sendo que cada diretório pode conte-los. O \mintinline{bash}{-d $'\0'} tem um
papel importante, visto que como nós estamos a passar uma string de paths
separados por \Verb|'\0'| é essencial neste passo mudar o delimitador do
\mintinline{bash}{while read} para o \Verb|'\0'|.

Com isto podemos começar a procurar os ficheiros a serem usados no calculo do
tamanho usando outro \mintinline{bash}{find}, contudo desta vez ele terá
algumas diferenças grandes.

\begin{listing}[H]
  \begin{minted}{bash}
    find "$path" "${FIND_OPTS[@]}" -type f -print0  2>/dev/null
  \end{minted}
\end{listing}

O \mintinline{bash}{path} vem do loop e o \mintinline{bash}{${FIND_OPTS[@]}}
será falado no processamento de argumentos, mas contém as opções relevantes
para a pesquisa de acordo com os argumentos passados pelo utilizador.

Além do array de opções a principal diferença deste \mintinline{bash}{find}
para o outro é que este apenas procura por ficheiros, e como no outro imprime
os caminhos separados por \Verb|'\0'|.

\subsection{Calcular o tamanho de cada diretório}

Uma vez que já temos uma lista com todos os ficheiros referentes a um
diretório, o ultimo passo que falta é calcular o tamanho de todos ficheiros.
Felizmente para nós o comando \mintinline{bash}{du} consegue facilmente fazer
isso para nós utilizando o seguinte comando.

\begin{listing}[H]
  \begin{minted}{bash}
    du -b --files0-from=- -cs 2>/dev/null | cut -f1 | tail -n1
  \end{minted}
\end{listing}

O commando \mintinline{bash}{du -b} serve para obter o espaço utilizado pelos
ficheiros em bytes. O argumento \mintinline{bash}{--files0-from=-} é bastante
importante aqui sendo que o seu significado é ler do \Verb|stdin| delimitado
por \Verb|'\0'|, que é como nós formatamos os dados no passo anterior com o
\mintinline{bash}{-print0} no \mintinline{bash}{find}. Por fim, usamos a opção
\mintinline{bash}{-cs} na qual o \Verb|c| mostra o total do tamanho dos
ficheiros passados (ou seja a soma) e o \Verb|s| serve para evitar repetições
(o seu unico proposito é eficiencia).

De seguida uso o comando \mintinline{bash}{cut -f1} para obter tudo até o
primeiro \Verb|'\t'| e por fim damos \mintinline{bash}{tail -n1} para extrair
so a ultima linha, que é a que contem o valor total.

\subsection{Processamento de argumentos}

Para o processamento dos argumentos usamos o comando \mintinline{bash}{getopts} com o padrão \mintinline{bash}{":hran:d:s:l:"}.

A opção \Verb|-h| imprime a seguinte mensagem:

\begin{listing}[H]
\begin{minted}{bash}
Usage: ./spacecheck.sh [options] [dir...]

Options:
	-h:          Shows this message
	-n PATTERN:  Filter files by name according to the pattern
	-d N:        Filter files by date of modification
	-s N:        Filter files by file size
	-r:          Print in reverse order
	-a:          Order by file name
	-l N:        Only show up to N lines
\end{minted}
\end{listing}

A opção \Verb|-n| está implementada da seguinte forma:

\begin{listing}[H]
\begin{minted}{bash}
pattern="$OPTARG"
FIND_OPTS+=("-regextype" "posix-extended" "-regex" "^.*/$pattern$")
\end{minted}
\end{listing}

Adicionamos às opções do comando \mintinline{bash}{find} o tipo de regex que é \Verb|posix extended|, pelo que é um dos mais completos e utilizados.
De seguida passamos uma regex que processa tudo depois da ultima \Verb|'/'| de acordo com o padrão passado pelo utilizador.

As opções do \Verb|FIND_OPTS| são passadas no \Verb|find| falado anteriormente \ref{sec:find_opts}.

A opção \Verb|-d| está implementada da seguinte forma:

\begin{listing}[H]
\begin{minted}{bash}
			data="$OPTARG"
			timestamp="@$(date -d "$data" +%s)"
			FIND_OPTS+=("-newermt" "$timestamp")
\end{minted}
\end{listing}

A opção \Verb|-newermt| do find faz exatamente isso tendo como argumento a data em tempo unix, que é obtido usando \mintinline{bash}{date -d "$data" +%s}.

Quanto à opção \Verb|-s| a forma como é implementada é semelhante às outras:

\begin{listing}[H]
  \begin{minted}{bash}
			tamanho="$OPTARG"
      if [[ "${tamanho:0-1}" =~ ^[0-9]+$ ]]; then
				tamanho+="c"
			fi
			if [[ "${tamanho:0:1}" =~ ^[0-9]+$ ]]; then
				tamanho="+$tamanho"
			fi
			FIND_OPTS+=("-size" "$tamanho")
  \end{minted}
\end{listing}

O primeiro \Verb|if| verifica se o ultimo carater é um número e caso seja adiciona um \Verb|'c'| no fim da string.
O \Verb|'c'| é para dizer que o tamanho está especificado em bytes.

O segundo \Verb|if| verifica se o primeiro carater é um número e caso seja adiciona um \Verb|'+'| no inicio da string.
O \Verb|'+'| é para especificar o tamanho é maior do que o tamanho passado.

A opção \Verb|-r| está implementada de uma forma diferente sendo que no processamento dos argumentos apenas faz \mintinline{bash}{REVERSE_SORT=true}

A opção \Verb|-a| está implementada da mesma forma que o \Verb|-r| sendo que apenas faz \mintinline{bash}{NAME_SORT=true}

Por fim a opção \Verb|-l| adiciona a um array \Verb|HEAD_OPTS| o valor passado pelo utilizador.

\begin{listing}[H]
  \begin{minted}{bash}
      linhas="$OPTARG"
      HEAD_OPTS+=("-n" "$linhas")
  \end{minted}
\end{listing}

\subsection{Ordenar o output}

\subsection{Escolher o número de linhas}

\section{Spacerate}

\subsection{Extrair os dados para um dicionário}

\subsection{Obter uma lista de todos os caminhos}

\subsection{Obter as diferenças entre cada ficheiro}

