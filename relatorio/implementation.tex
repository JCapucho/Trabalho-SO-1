\chapter{Implementação}

\section{Introdução}

Neste trabalho foi nos pedido que críassemos dois scripts \emph{Bash}:
\Verb|spacecheck.sh| e \Verb|spacerate.sh|, cada um destes desempharia uma
função diferente mas complementares.

O script \Verb|spacecheck.sh| é responsável por produzir um relatório que
detalha o espaço ocupado por um diretório e como está distribuído pelos seus
subdiretórios, com opções extra para controlar quais ficheiros contam para esta
métrica.

Os resultados da execução poderiam depois ser comparados com recurso ao script
\Verb|spacerate.sh|, este calcularia a diferença entre os resultados e
apresentaria ao utilizador como o tamanho dos diretórios variou e se foram
introduzidos diretórios novos ou removidos.

Nesta secção vamos detalhar como implementamos os nossos scripts, incluindo não
só como funcionam mas também a lógica por detrás das nossas decisões para os
construir desta maneira.

Os scripts possuem uma parte semelhante aos dois significativa (por exemplo, o
processamento de argumentos e o ordenamento de resultados) como tal iremos
começar por discutir as partes específicas a cada programa e de seguida
abordaremos as partes comuns.

\cprotect\section{\Verb|spacecheck.sh|}

O script \Verb|spacecheck.sh| como já foi referido mostra o espaço ocupado por
um diretório e todos os seus sub diretórios, possuindo opções para filtrar os
ficheiros a usar no cálculo do espaço ocupado.

Podemos então dividir a implementação em três grandes problemas a resolver:

\begin{enumerate}
	\item Encontrar os diretórios e subdiretórios
	\item Escolher os ficheiros que contam
	\item Calcular o tamanho do diretório
\end{enumerate}

Vamos então começar por explorar cada um destes problemas e como foram resolvidos.

\subsection{Encontrar os diretórios}

O primeiro passo então é descobrir todos os diretórios e subdiretórios que terão
de ser considerados pelo script.

O comando \Verb|find| é ideal para esta situação, este permite descobrir
recursivamente os ficheiros e subdiretórios de vários diretórios que são
passados como argumentos. Além disso conseguimos filtrar os resultados para só
obter diretórios. Logo uma primeira versão para resolver este problema seria
parecida com algo semelhante ao código
\ref{code:implementation_first_subdir_find}.

\begin{listing}[H]
	\centering
	\begin{minted}{bash}
    find "$@" -type d
  \end{minted}
	\caption{Exemplo de como obter os subdiretórios}
	\label{code:implementation_first_subdir_find}
\end{listing}

Este código parece ser a solução ideal para o problema, e em alguns aspetos é,
por exemplo, esta primeira versão lida corretamente com argumentos que têm
espaços. Mas o problema desta solução não é o facto de funcionar mas o resultado
que produz.

Se por exemplo, executássemos este comando num diretório \Verb|test| que têm
dois subdiretórios \Verb|a| e \Verb|b|, obteríamos o seguinte resultado:

\begin{listing}[H]
	\centering
	\begin{minted}{text}
    test
    test/a
    test/b
  \end{minted}
	\cprotect\caption{Exemplo do resutlado obtido pelo \Verb|find|}
\end{listing}

Como podemos ver os resultados vêm separados por linhas novas (\Verb|\n|), isto
para a vasta maioria dos casos funciona, no entanto a norma \emph{POSIX} define
que um nome de ficheiro/diretório pode ser constituído por qualquer byte com a
exceção do byte nulo (\bashinline|\0|) e da barra (\bashinline|/|)
\cite{posix_path}.

Isto implica que \bashinline|a\nd| é um nome completamente válido para um diretório,
se executarmos o mesmo comando no diretório \Verb|test| onde agora existe este
subdiretório, obtemos o seguinte resultado.

\begin{listing}[H]
	\centering
	\begin{minted}{text}
    test/a
    d
    test/a
    test/b
  \end{minted}
	\caption{Resultado obtido com um diretório que contêm uma linha nova}
\end{listing}

Apesar disto ser uma situação rara é uma possibilidade e como tal temos de a
acautelar no nosso programa, mas já vimos que o caminho não pode conter bytes
nulos e o \Verb|find| contêm uma opção \Verb|-print0| que invês de separar os
resultados com uma linha nova, vai separar com o byte nulo \cite{find_man}.

Chegamos assim então a segunda iteração do comando para obter os diretórios e
subdiretórios apresentado no código \ref{code:implementation_second_subdir_find}.

\begin{listing}[H]
	\centering
	\begin{minted}{bash}
    find "$@" -type d -print0
  \end{minted}
	\caption{Segundo iteração do comando para obter os subdiretórios}
	\label{code:implementation_second_subdir_find}
\end{listing}

No entanto esta versão ainda tem um problema, como já vimos os diretórios podem
ter nomes pouco convencionais e se o nome começar com um híphen (\Verb|-|),
estes vão ser interpretados pelo \Verb|find| como opções. Para resolver isto
vamos ter de escapar manualmente todos os diretórios que começam com um híphen
\footnote{Mais a frente o mesmo problema terá de ser resolvido noutros comandos,
	estes ou aceitam um argumento especial \Verb|--| que sinaliza o fim das opções,
	ou têm uma opção \Verb|-files0-from|. O primeiro não existe no \Verb|find|
	devido a ordem pouco convencional dos argumentos, o segundo existe em algumas
	versões do \Verb|find| mas é pouco comum, principalmente em distribuições que
	não são baseadas nas ferramentas GNU. Logo decidimos pela opção manual.}.

\begin{listing}[H]
	\centering
	\begin{minted}{bash}
    DIRS_TO_SEARCH=()

    for dir in "$@"; do
      if [ ! -d "$dir" ]; then
        1>&2 echo "ERROR: \"$dir\" does not exist"
      fi
      case "$dir" in
        -*)
          if [ ! -d "$dir" ]; then
            1>&2 echo "+note: did you mean to pass an argument?"
            1>&2 echo "       all arguments must precede the directory paths"
          fi
          # Add `./` to directories beginning with a dash (`-`), so that find
          # doesn't mistake them, for options.
          DIRS_TO_SEARCH+=("./$dir");;
        *)
          DIRS_TO_SEARCH+=("$dir");;
      esac
    done
  \end{minted}
	\caption{Implementação do escape de diretorias começadas por híphen}
	\label{code:implementation_escape_options_find}
\end{listing}

O código \ref{code:implementation_escape_options_find}, mostra a implementação
final para escapar os híphens no início do nome dos diretórios. Este código
ainda implementa mensagens de erro para diretórios que não existem e mensagens
de ajuda casos esses diretórios pareçam ser opções.

Finalmente, é apresentado no código \ref{code:implementation_final_subdir_find}
a implementação final do comando para obter os diretórios e subdiretórios.

\begin{listing}[H]
	\centering
	\begin{minted}{bash}
    find "${DIRS_TO_SEARCH[@]}" -type d -print0
  \end{minted}
	\caption{Iteração final do comando para obter os subdiretórios}
	\label{code:implementation_final_subdir_find}
\end{listing}

\subsection{Escolher os ficheiros}

Após obter os diretórios todos é importante conseguir trabalhar sobre cada um deles, para isso usamos o \bashinline{while read} da seguinte maneira:

\begin{listing}[H]
	\centering
	\begin{minted}{bash}
    while IFS= read -r -d $'\0' path; do
      // ...
    done
  \end{minted}
\end{listing}

Aqui colocamos o \bashinline{IFS} nulo para não separar por espaços,
sendo que diretórios podem conte-los e não queremos cortá-los. O \bashinline|-d $'\0'| tem um
papel importante, visto que como nós estamos a passar uma string de caminhos
separados por \Verb|'\0'| é essencial neste passo mudar o delimitador do
\bashinline{while read} para o \Verb|'\0'|.

Com isto podemos começar a procurar os ficheiros a serem usados no cálculo do
tamanho através de outro \bashinline{find}, contudo desta vez ele terá
algumas diferenças.

\begin{listing}[H]
	\centering
	\begin{minted}{bash}
    find "$path" "${FIND_OPTS[@]}" -type f -print0  2>/dev/null
  \end{minted}
\end{listing}

O \bashinline{path} vem do loop e o \bashinline|${FIND_OPTS[@]}|
será falado no processamento de argumentos (\ref{sec:implementation_arg_parsing}), mas contém as opções relevantes
para a pesquisa de acordo com os argumentos passados pelo utilizador.\label{sec:implementation_find_opts}

Além do array de opções a principal diferença deste \bashinline{find}
para o outro é que este apenas procura por ficheiros (\Verb|type -f|) mas tal como no outro imprime
os caminhos separados por \Verb|'\0'|.

\subsection{Calcular o tamanho de cada diretório}

Uma vez que já temos uma lista com todos os ficheiros referentes a um
diretório, o último passo que falta é calcular o tamanho de todos ficheiros.
Felizmente para nós o comando \bashinline{du} consegue facilmente fazer
isso utilizando o seguinte comando.

\begin{listing}[H]
	\centering
	\begin{minted}{bash}
    du -b --files0-from=- -cs 2>/dev/null | cut -f1 | tail -n1
  \end{minted}
\end{listing}

O commando \bashinline{du -b} serve para obter o espaço utilizado pelos
ficheiros em bytes. O argumento \bashinline{--files0-from=-} é necessário aqui visto que serve para ler caminhos do \Verb|stdin| separados por \Verb|'\0'|, que é como nós formatámos os dados no passo anterior com o
\bashinline{-print0} no \bashinline{find}. Por fim, usamos a opção
\bashinline{-cs} na qual o \Verb|c| mostra a soma dos tamanhos de todos os ficheiros e o \Verb|s| serve para evitar repetições
(o seu único propósito é eficiência).

De seguida usamos o comando \bashinline{cut -f1} para obter tudo até o
primeiro \Verb|'\t'| e, por fim, damos \bashinline{tail -n1} para extrair
só a última linha, que é a que contém o valor total.

Se ocorrer algum erro no \bashinline{du} o tamanho do diretório será substituido por \Verb|NA|.

\subsection{Processamento de argumentos}\label{sec:implementation_arg_parsing}

Para o processamento dos argumentos usamos o comando \bashinline{getopts} com o padrão \bashinline{":hran:d:s:l:"}.

A opção \Verb|-h| imprime a seguinte mensagem:

\begin{listing}[H]
	\centering
	\begin{minted}{text}
    Usage: ./spacecheck.sh [options] [dir...]

    Options:
      -h:          Shows this message
      -n PATTERN:  Filter files by name according to the pattern
      -d N:        Filter files by date of modification
      -s N:        Filter files by file size
      -r:          Print in reverse order
      -a:          Order by file name
      -l N:        Only show up to N lines
  \end{minted}
\end{listing}

A opção \Verb|-n| está implementada da seguinte forma:

\begin{listing}[H]
	\centering
	\begin{minted}{bash}
    pattern="$OPTARG"
    FIND_OPTS+=("-regextype" "posix-extended" "-regex" "^.*/$pattern$")
  \end{minted}
\end{listing}

Começamos por escolher o tipo de expressão regular que queremos usar, neste caso \Verb|posix-extended|.
De seguida passamos uma expressão regular que processa tudo depois da última \Verb|'/'| de acordo com o padrão passado pelo utilizador.
As opções do \Verb|FIND_OPTS| são usadas pelo \Verb|find| falado anteriormente (\ref{sec:implementation_find_opts}).

A opção \Verb|-d| está implementada da seguinte forma:

\begin{listing}[H]
	\centering
	\begin{minted}{bash}
			data="$OPTARG"
			timestamp="@$(date -d "$data" +%s)"
			FIND_OPTS+=("-newermt" "$timestamp")
  \end{minted}
\end{listing}

A opção \Verb|-newermt| faz com que o \Verb|find| apenas procure por ficheiros com data de modificação mais recente ou igual à data passada. Esta é convertida para unix time através do comando \bashinline{date -d "$data" +%s}, e é assim que é passada ao \Verb|find|.

Quanto à opção \Verb|-s| a forma como é implementada é semelhante às outras:

\begin{listing}[H]
	\centering
	\begin{minted}{bash}
    tamanho="$OPTARG"
    if [[ "${tamanho:0-1}" =~ ^[0-9]+$ ]]; then
      tamanho+="c"
    fi
    if [[ "${tamanho:0:1}" =~ ^[0-9]+$ ]]; then
      tamanho="+$tamanho"
    fi
    FIND_OPTS+=("-size" "$tamanho")
  \end{minted}
\end{listing}

O primeiro \Verb|if| verifica se o último caráter é um número e caso seja adiciona um \Verb|'c'| no fim da string.
O \Verb|'c'| é para dizer que o tamanho está especificado em bytes.

O segundo \Verb|if| verifica se o primeiro caráter é um número e caso seja adiciona um \Verb|'+'| no inicio da string.
O \Verb|'+'| é para especificar o tamanho dos ficheiros tem de ser maior do que o tamanho passado.

A opção \Verb|-r| está implementada de uma forma diferente sendo que no processamento dos argumentos apenas faz \bashinline{REVERSE_SORT=true}

A opção \Verb|-a| está implementada da mesma forma que o \Verb|-r| sendo que apenas faz \bashinline{NAME_SORT=true}

Por fim a opção \Verb|-l| adiciona a um array \Verb|HEAD_OPTS| a opção do \Verb|head| com o número de linhas passado pelo utilizador.

\begin{listing}[H]
	\centering
	\begin{minted}{bash}
      linhas="$OPTARG"
      HEAD_OPTS+=("-n" "$linhas")
  \end{minted}
\end{listing}

\subsection{Ordenar o output}\label{sec:implementation_sort}

Para ordenar o output começamos por criar um array com todas as opções que serão utilizadas para no \Verb|sort|:

\begin{listing}[H]
	\centering
	\begin{minted}{bash}
    NAME_REVERSE_SUFFIX=$([ "$REVERSE_SORT" = false ] && echo "" || echo "r")
    SIZE_REVERSE_SUFFIX=$([ "$REVERSE_SORT" = true ] && echo "" || echo "r")

    SORT_BY_NAME=("-k" "2$NAME_REVERSE_SUFFIX")
    SORT_BY_SIZE=("-k" "1,1n$SIZE_REVERSE_SUFFIX")

    if [ "$NAME_SORT" = true ] ; then
      SORT_OPTS+=( "${SORT_BY_NAME[@]}" "${SORT_BY_SIZE[@]}" )
    else
      SORT_OPTS+=( "${SORT_BY_SIZE[@]}" "${SORT_BY_NAME[@]}" )
    fi
  \end{minted}
\end{listing}

O primeiro passo é saber se a ordem tem de ser inversa ou não.
Para isso criamos duas variáveis \Verb|NAME_REVERSE_SUFFIX| e \Verb|SIZE_REVERSE_SUFFIX| que contêm o sufixo \Verb|r| ou são uma string vazia.
No caso do \Verb|SIZE_REVERSE_SUFFIX| ele por padrão vai ter o sufixo \Verb|r| visto que é a ordem pretendida quando não se passam argumentos ao script.

Após isso criamos dois arrays \Verb|SORT_BY_NAME| e \Verb|SORT_BY_SIZE| que contêm as opções para ordenar por nome e por tamanho respetivamente.

A opção \Verb|-k| do sort serve para especificar as colunas a serem usadas para ordenar.
No primeiro array a coluna escolhida é a segunda e é concatenada com o sufixo \Verb|NAME_REVERSE_SUFFIX| que é \Verb|r| caso a ordem seja inversa e vazio caso não seja.
De forma semelhante no segundo array a coluna escolhida é a primeira com a opção \Verb|n| que serve para comparar numericamente e é concatenada com o sufixo \Verb|SIZE_REVERSE_SUFFIX| que é vazio caso a ordem seja inversa e \Verb|'r'| caso não seja.

É importante notar que o -k escolhe em que coluna começar e em qual acabar, sendo o padrão começar na coluna escolhida e acabar na última.
Por isso aqui no primeiro array apenas é especificada a coluna 2 e no segundo é especificada a coluna de inicio 1 e a de fim também 1.

Após isso é verificado se a ordem é por nome ou por tamanho e adicionado ao array \Verb|SORT_OPTS| as opções respetivas pela ordem correta.

Por fim, para ordenar o output é usado o command \bashinline{sort "${SORT_OPTS[@]}"} no fim do \Verb|while|.

\subsection{Escolher o número de linhas}\label{sec:implementation_head}

O último passo é escolher o número de linhas a serem impressas.
Como já temos o array \Verb|HEAD_OPTS| basta passar o output ordenado ao seguinte comando:

\begin{listing}[H]
	\centering
	\begin{minted}{bash}
    [ "${#HEAD_OPTS[@]}" -lt 1 ] && cat || head "${HEAD_OPTS[@]}"
  \end{minted}
\end{listing}

Se o número de opções for menor que 1 então imprime tudo, caso contrário imprime apenas as primeiras linhas.

\section{Spacerate}

\subsection{Extrair os dados para dicionários}

O primeiro e principal passo para começar a comparar os diretórios é colocá-los numa estrutura de dados que seja fácil de manipular.
Para isso começamos por declarar dois dicionários, um para cada ficheiro, mas também será criado um terceiro dicionário que será usado para obter todos os diretórios dos dois ficheiros, sem repetições.

\begin{listing}[H]
	\centering
	\begin{minted}{bash}
    declare -A SPACECHECK_NEWEST
    declare -A SPACECHECK_OLDEST

    declare -A DIRECTORIES
  \end{minted}
\end{listing}

Para facilitar a leitura do código chamamos ao primeiro ficheiro \Verb|NEWESTFILE| e ao segundo \Verb|OLDESTFILE|.

Após isso são feitos dois \bashinline{while read} um para cada ficheiro passado como argumento ao script.

\begin{listing}[H]
	\centering
	\begin{minted}{bash}
    while IFS=$'\n' read -r line; do
      # ...
    done < <(tail -n +2 -- "$NEWESTFILE")
  \end{minted}
\end{listing}

O mesmo faz-se para o \Verb|OLDESTFILE|.

O \bashinline{tail -n +2} serve para ignorar a primeira linha do ficheiro, que contém o header.
DOUBLE CHECK THIS
O \bashinline|IFS=$'\n'| serve para separar as linhas por \Verb|'\n'| e não por espaços.

Dentro do loop é feito o parsing de cada linha do ficheiro da seguinte maneira:

\begin{listing}[H]
	\centering
	\begin{minted}{bash}
      size=$(echo "$line" | cut -f1)
      name=$(echo "$line" | cut -f2-)
      SPACECHECK_NEWEST["$name"]="$size"
      DIRECTORIES["$name"]=1
  \end{minted}
\end{listing}

Como as colunas estão separadas por \Verb|'\t'| usamos o \bashinline{cut -f1} para obter a primeira coluna e o \bashinline{cut -f2-} para obter todas as outras.
Após isso é adicionado ao dicionário \Verb|SPACECHECK_NEWEST| o nome do ficheiro como chave e o tamanho como valor.
Ao mesmo tempo também adicionamos ao dicionário \Verb|DIRECTORIES| o nome do ficheiro como chave e o valor 1, que como é um dicionário não repete as chaves, logo vamos obter uma lista com todos os diretórios dos dois ficheiros.

\subsection{Obter as diferenças entre cada ficheiro}

Agora que já temos os dados guardados em dicionários podemos começar a comparar os dois ficheiros.
Para isso começamos por iterar sobre os diretórios.

\begin{listing}[H]
	\centering
	\begin{minted}{bash}
    for key in "${!DIRECTORIES[@]}"; do
      # ...
    done
  \end{minted}
\end{listing}

Para simplificar o código guardamos os tamanhos dos diretórios em variáveis.

\begin{listing}[H]
	\centering
	\begin{minted}{bash}
      old_size="${SPACECHECK_OLDEST[$key]}"
      new_size="${SPACECHECK_NEWEST[$key]}"
  \end{minted}
\end{listing}

Caso o \Verb|old_size| seja vazio significa que o diretório não existe no ficheiro antigo mas existe no novo, logo não precisamos de calcular a diferença e baste adicionar \Verb|NEW| no fim.

\begin{listing}[H]
	\centering
	\begin{minted}{bash}
      if [ -z "$old_size" ]; then
        echo -e "$new_size\t$key\tNEW"
      ...
  \end{minted}
\end{listing}

Caso o \Verb|new_size| seja vazio significa que o diretório não existe no ficheiro novo mas existe no antigo, logo não precisamos de calcular a diferença e baste adicionar \Verb|REMOVED| no fim e fazer o inverso do tamanho, ou seja, adicionar um \Verb|'-'| no inicio do size.

\begin{listing}[H]
	\centering
	\begin{minted}{bash}
    ...
    elif [ -z "$new_size" ]; then
      if [ "$old_size" == "0" ] || [ "$old_size" == "NA" ]; then
        display_size="$old_size"
      else
        display_size="-$old_size"
      fi

      echo -e "$display_size\t$key\tREMOVED"
    ...
  \end{minted}
\end{listing}

Aqui para não imprimir \Verb|"-0"| ou \Verb|"-NA"| nos casos em que o \Verb|old_size| é \Verb|0| ou \Verb|NA| criamos uma variável \Verb|display_size| que vai ser usada para imprimir o tamanho.

Caso algum dos dois tamanhos seja \Verb|NA| o resultado impresso será \Verb|NA|.

\begin{listing}[H]
	\centering
	\begin{minted}{bash}
    ...
    elif [ "$old_size" == "NA" ] || [ "$new_size" == "NA" ]; then
      echo -e "NA\t$key"
    ...
  \end{minted}
\end{listing}

Por fim, se os dois tamanhos existirem e não forem \Verb|NA| então calculamos a diferença entre eles e imprimimos o resultado.

\begin{listing}[H]
	\centering
	\begin{minted}{bash}
    else
      diff=$((new_size - old_size))
      echo -e "$diff\t$key"
    fi
    ...
  \end{minted}
\end{listing}

\subsection{Processamento de argumentos}

Para o processamento dos argumentos usamos o comando \bashinline{getopts} com o padrão \bashinline{":hral:"}.

A opção \Verb|-h| imprime a seguinte mensagem:

\begin{listing}[H]
	\centering
	\begin{minted}{text}
    Usage: spacerate.sh [options] <new> <old>

    Options:
      -h:          Shows this message
      -r:          Print in reverse order
      -a:          Order by file name
      -l N:        Only show up to N lines
  \end{minted}
\end{listing}

Em relação ao processamento dos argumentos é feito da mesma forma que no \bashinline{spacecheck.sh} mas sem os argumentos que não se aplicam. (\ref{sec:implementation_arg_parsing})

\subsection{Ordenar o output}

Ver \ref{sec:implementation_sort}

\subsection{Escolher o número de linhas}

Ver \ref{sec:implementation_head}


\section{Conclusão}

Todos os argumentos e ficheiros são validados e caso não sejam válidos é impressa uma mensagem de erro e o programa termina.

Além disso são verificados casos especiais como diretórios com um \Verb|'-'| no inicio.

\begin{listing}[H]
	\centering
	\begin{minted}{bash}
    for dir in "$@"; do
      if [ ! -d "$dir" ]; then
        1>&2 echo "ERROR: \"$dir\" does not exist"
      fi
      case "$dir" in
        -*)
          if [ ! -d "$dir" ]; then
            1>&2 echo "+note: did you mean to pass an argument?"
            1>&2 echo "       all arguments must precede the directory paths"
          fi
          # Add `./` to directories beginning with a dash (`-`), so that find, doesn't
          # mistake them, for functions.
          DIRS_TO_SEARCH+=("./$dir");;
        *)
          DIRS_TO_SEARCH+=("$dir");;
      esac
    done
  \end{minted}
\end{listing}
