\chapter{Implementação}

\section{Spacecheck}

\subsection{Encontrar os diretórios}

Para conseguir gerir e monitorizar o espaço ocupado em disco dentro de
diretórios é primeiro essencial saber quais são os diretórios a ser usados.

Usando os argumentos passados ao script com os diretórios a serem pesquisados,
descobrimos os seus sub-diretórios todos atraves do comando
\mintinline{bash}{find} da seguinte maneira:
\begin{listing}[H]
  \begin{minted}{bash}
    find "$@" -type d -print0 2>/dev/null
  \end{minted}
\end{listing}
Procuramos dentro dos diretórios passados todos os seus sub-diretórios
(\mintinline{bash}{-type d}). Todos os erros não nos são relevantes por isso
não os imprimimos. A forma como os caminhos dos diretórios são impressos também
é relevante sendo que eles acabam com \Verb|'\0'| e não \Verb|'\n'| como normalmente
seriam.

O motivo para fazer a impressão dos caminhos desta maneira será evidente mais
tarde quanto começarmos a iterar sobre eles.

\subsection{Escolher os ficheiros}

Após obter todos os sub-diretórios dos diretórios passados é importante
conseguir trabalhar sobre cada um deles, para isso usamos o
\mintinline{bash}{while read} da seguinte maneira:

\mintinline{bash}{find} da seguinte maneira:
\begin{listing}[H]
  \begin{minted}{bash}
    while IFS= read -r -d $'\0' path; do
      // ...
    done
  \end{minted}
\end{listing}

Aqui colocamos o \mintinline{bash}{IFS} nulo para não separar por espaços,
sendo que cada diretório pode conte-los. O \mintinline{bash}{-d $'\0'} tem um
papel importante, visto que como nós estamos a passar uma string de paths
separados por \Verb|'\0'| é essencial neste passo mudar o delimitador do
\mintinline{bash}{while read} para o \Verb|'\0'|.

Com isto podemos começar a procurar os ficheiros a serem usados no calculo do
tamanho usando outro \mintinline{bash}{find}, contudo desta vez ele terá
algumas diferenças grandes.

\begin{listing}[H]
  \begin{minted}{bash}
    find "$path" "${FIND_OPTS[@]}" -type f -print0  2>/dev/null
  \end{minted}
\end{listing}

O \mintinline{bash}{path} vem do loop e o \mintinline{bash}{${FIND_OPTS[@]}}
será falado no processamento de argumentos, mas contém as opções relevantes
para a pesquisa de acordo com os argumentos passados pelo utilizador.\label{sec:find_opts}

Além do array de opções a principal diferença deste \mintinline{bash}{find}
para o outro é que este apenas procura por ficheiros, e como no outro imprime
os caminhos separados por \Verb|'\0'|.

\subsection{Calcular o tamanho de cada diretório}

Uma vez que já temos uma lista com todos os ficheiros referentes a um
diretório, o ultimo passo que falta é calcular o tamanho de todos ficheiros.
Felizmente para nós o comando \mintinline{bash}{du} consegue facilmente fazer
isso para nós utilizando o seguinte comando.

\begin{listing}[H]
  \begin{minted}{bash}
    du -b --files0-from=- -cs 2>/dev/null | cut -f1 | tail -n1
  \end{minted}
\end{listing}

O commando \mintinline{bash}{du -b} serve para obter o espaço utilizado pelos
ficheiros em bytes. O argumento \mintinline{bash}{--files0-from=-} é bastante
importante aqui sendo que o seu significado é ler do \Verb|stdin| delimitado
por \Verb|'\0'|, que é como nós formatamos os dados no passo anterior com o
\mintinline{bash}{-print0} no \mintinline{bash}{find}. Por fim, usamos a opção
\mintinline{bash}{-cs} na qual o \Verb|c| mostra o total do tamanho dos
ficheiros passados (ou seja a soma) e o \Verb|s| serve para evitar repetições
(o seu unico proposito é eficiencia).

De seguida uso o comando \mintinline{bash}{cut -f1} para obter tudo até o
primeiro \Verb|'\t'| e por fim damos \mintinline{bash}{tail -n1} para extrair
so a ultima linha, que é a que contem o valor total.

\subsection{Processamento de argumentos}

Para o processamento dos argumentos usamos o comando \mintinline{bash}{getopts} com o padrão \mintinline{bash}{":hran:d:s:l:"}.

A opção \Verb|-h| imprime a seguinte mensagem:

\begin{listing}[H]
\begin{minted}{bash}
Usage: ./spacecheck.sh [options] [dir...]

Options:
	-h:          Shows this message
	-n PATTERN:  Filter files by name according to the pattern
	-d N:        Filter files by date of modification
	-s N:        Filter files by file size
	-r:          Print in reverse order
	-a:          Order by file name
	-l N:        Only show up to N lines
\end{minted}
\end{listing}

A opção \Verb|-n| está implementada da seguinte forma:

\begin{listing}[H]
\begin{minted}{bash}
pattern="$OPTARG"
FIND_OPTS+=("-regextype" "posix-extended" "-regex" "^.*/$pattern$")
\end{minted}
\end{listing}

Adicionamos às opções do comando \mintinline{bash}{find} o tipo de regex que é \Verb|posix extended|, pelo que é um dos mais completos e utilizados.
De seguida passamos uma regex que processa tudo depois da ultima \Verb|'/'| de acordo com o padrão passado pelo utilizador.

As opções do \Verb|FIND_OPTS| são passadas no \Verb|find| falado anteriormente \ref{sec:find_opts}.

A opção \Verb|-d| está implementada da seguinte forma:

\begin{listing}[H]
\begin{minted}{bash}
			data="$OPTARG"
			timestamp="@$(date -d "$data" +%s)"
			FIND_OPTS+=("-newermt" "$timestamp")
\end{minted}
\end{listing}

A opção \Verb|-newermt| do find faz exatamente isso tendo como argumento a data em tempo unix, que é obtido usando \mintinline{bash}{date -d "$data" +%s}.

Quanto à opção \Verb|-s| a forma como é implementada é semelhante às outras:

\begin{listing}[H]
  \begin{minted}{bash}
			tamanho="$OPTARG"
      if [[ "${tamanho:0-1}" =~ ^[0-9]+$ ]]; then
				tamanho+="c"
			fi
			if [[ "${tamanho:0:1}" =~ ^[0-9]+$ ]]; then
				tamanho="+$tamanho"
			fi
			FIND_OPTS+=("-size" "$tamanho")
  \end{minted}
\end{listing}

O primeiro \Verb|if| verifica se o ultimo carater é um número e caso seja adiciona um \Verb|'c'| no fim da string.
O \Verb|'c'| é para dizer que o tamanho está especificado em bytes.

O segundo \Verb|if| verifica se o primeiro carater é um número e caso seja adiciona um \Verb|'+'| no inicio da string.
O \Verb|'+'| é para especificar o tamanho é maior do que o tamanho passado.

A opção \Verb|-r| está implementada de uma forma diferente sendo que no processamento dos argumentos apenas faz \mintinline{bash}{REVERSE_SORT=true}

A opção \Verb|-a| está implementada da mesma forma que o \Verb|-r| sendo que apenas faz \mintinline{bash}{NAME_SORT=true}

Por fim a opção \Verb|-l| adiciona a um array \Verb|HEAD_OPTS| o valor passado pelo utilizador.

\begin{listing}[H]
  \begin{minted}{bash}
      linhas="$OPTARG"
      HEAD_OPTS+=("-n" "$linhas")
  \end{minted}
\end{listing}

\subsection{Ordenar o output}\label{sec:sort}

Para ordenar o output começamos por criar um array com todas as opções que serão utilizadas para o sort:

\begin{listing}[H]
  \begin{minted}{bash}
    NAME_REVERSE_PREFIX=$([ "$REVERSE_SORT" = false ] && echo "" || echo "r")
    SIZE_REVERSE_PREFIX=$([ "$REVERSE_SORT" = true ] && echo "" || echo "r")

    SORT_BY_NAME=("-k" "2$NAME_REVERSE_PREFIX")
    SORT_BY_SIZE=("-k" "1,1n$SIZE_REVERSE_PREFIX")

    if [ "$NAME_SORT" = true ] ; then
      SORT_OPTS+=( "${SORT_BY_NAME[@]}" "${SORT_BY_SIZE[@]}" )
    else
      SORT_OPTS+=( "${SORT_BY_SIZE[@]}" "${SORT_BY_NAME[@]}" )
    fi
  \end{minted}
\end{listing}

O primeiro passo é saber se a ordem tem de ser inversa ou não.
Para isso criamos duas variáveis \Verb|NAME_REVERSE_PREFIX| e \Verb|SIZE_REVERSE_PREFIX| que contêm o prefixo \Verb|-r| para o sort.

Após isso criamos dois arrays \Verb|SORT_BY_NAME| e \Verb|SORT_BY_SIZE| que contêm as opções para ordenar por nome e por tamanho respetivamente.

A opção \Verb|-k| do sort serve para especificar as colunas a serem usadas para ordenar.
No primeiro array a coluna escolhida é a segunda e é concatenada com o prefixo \Verb|NAME_REVERSE_PREFIX| que é vazio caso a ordem seja inversa e \Verb|'r'| caso não seja.
De forma semelhante no segundo array a coluna escolhida é a primeira com a opção \Verb|n| que serve para comparar numericamente e é concatenada com o prefixo \Verb|SIZE_REVERSE_PREFIX| que é vazio caso a ordem seja inversa e \Verb|'r'| caso não seja.
É importante notar que o -k escolhe em que coluna começar e em qual acabar, sendo o padrão começar na coluna escolhida e acabar na ultima.
Por isso aqui no primeiro array apenas é especificada a coluna 2 e no segundo é especificada a coluna de inicio 1 e a de fim também 1.

Após isso é verificado se a ordem é por nome ou por tamanho e adicionado ao array \Verb|SORT_OPTS| as opções respetivas pela ordem correta.

Por fim, para ordenar o output é usado o command \mintinline{bash}{sort "${SORT_OPTS[@]}"} no fim do \Verb|while|.

\subsection{Escolher o número de linhas}\label{sec:head}

O ultimo passo é escolher o número de linhas a serem impressas.
Como já temos o array \Verb|HEAD_OPTS| basta fazer para:

\begin{listing}[H]
  \begin{minted}{bash}
    [ "${#HEAD_OPTS[@]}" -lt 1 ] && cat || head "${HEAD_OPTS[@]}"
  \end{minted}
\end{listing}

Se o número de opções for menor que 1 então imprime tudo, caso contrário imprime apenas as primeiras linhas.

\section{Spacerate}

\subsection{Extrair os dados para dicionários}

O primeiro e principal passo para começar a comparar os diretórios é colocá-los numa estrutura de dados que seja fácil de manipular.
Para isso começamos por declarar dois dicionários vazios, um para cada ficheiro, mas também será criado um terceiro dicionário que será usado para obter todos os diretórios dos dois ficheiros, sem repetições.

\begin{listing}[H]
  \begin{minted}{bash}
    declare -A SPACECHECK_NEWEST
    declare -A SPACECHECK_OLDEST

    declare -A DIRECTORIES
  \end{minted}
\end{listing}

Após isso é feito um \mintinline{bash}{while read} sobre os dois ficheiros passados como argumento ao script.

\begin{listing}[H]
  \begin{minted}{bash}
    while IFS=$'\n' read -r line; do
      # ...
    done < <(tail -n +2 -- "$NEWESTFILE")
  \end{minted}
\end{listing}

O mesmo faz-se para o ficheiro mais antigo.

O \mintinline{bash}{tail -n +2} serve para ignorar a primeira linha do ficheiro, que contém o header.
O \mintinline{bash}{IFS=$'\n'} serve para separar as linhas por \Verb|'\n'| e não por espaços.

Dentro do loop é feito o parsing de cada linha do ficheiro da seguinte maneira:

\begin{listing}[H]
  \begin{minted}{bash}
      size=$(echo "$line" | cut -f1)
      name=$(echo "$line" | cut -f2-)
      SPACECHECK_NEWEST["$name"]="$size"
      DIRECTORIES["$name"]=1
  \end{minted}
\end{listing}

Como as colunas estão separadas por \Verb|'\t'| usamos o \mintinline{bash}{cut -f1} para obter a primeira coluna e o \mintinline{bash}{cut -f2-} para obter todas as outras.
Após isso é adicionado ao dicionário \Verb|SPACECHECK_NEWEST| o nome do ficheiro como chave e o tamanho como valor.
Ao mesmo tempo também adicionamos ao dicionário \Verb|DIRECTORIES| o nome do ficheiro como chave e o valor 1, que como é um dicionário não repete as chaves, logo vamos obter uma lista com todos os diretórios dos dois ficheiros.

\subsection{Obter as diferenças entre cada ficheiro}

Agora que já temos os dados guardados em dicionários podemos começar a comparar os dois ficheiros.
Para isso começamos por iterar sobre os diretórios.

\begin{listing}[H]
  \begin{minted}{bash}
    for key in "${!DIRECTORIES[@]}"; do
      # ...
    done
  \end{minted}
\end{listing}

Para simplificar o código guardamos os tamanhos dos diretórios em variáveis.

\begin{listing}[H]
  \begin{minted}{bash}
      old_size="${SPACECHECK_OLDEST[$key]}"
      new_size="${SPACECHECK_NEWEST[$key]}"
  \end{minted}
\end{listing}

Caso o \Verb|old_size| seja vazio significa que o diretório não existe no ficheiro antigo mas existe no novo, logo não precisamos de calcular a diferença e baste adicionar \Verb|NEW| no fim.

\begin{listing}[H]
  \begin{minted}{bash}
      if [ -z "$old_size" ]; then
        echo -e "$new_size\t$key\tNEW"
      ...
  \end{minted}
\end{listing}

Caso o \Verb|new_size| seja vazio significa que o diretório não existe no ficheiro novo mas existe no antigo, logo não precisamos de calcular a diferença e baste adicionar \Verb|REMOVED| no fim.

\begin{listing}[H]
  \begin{minted}{bash}
    ...
    elif [ -z "$new_size" ]; then
      if [ "$old_size" == "0" ]; then
        display_size="0"
      elif [ "$old_size" == "NA" ]; then
        display_size="NA"
      else
        display_size="-$old_size"
      fi

      echo -e "$display_size\t$key\tREMOVED"
    ...
  \end{minted}
\end{listing}

Aqui para não imprimir \Verb|"-0"| no caso do ficheiro não ocupar espaço adicionamos ainda uma condição a verificar se o tamanho é 0.
O mesmo acontece para o caso de ser \Verb|NA|.

Caso algum dos dois tamanhos seja \Verb|NA| o resultado impresso será \Verb|NA|.

\begin{listing}[H]
  \begin{minted}{bash}
    ...
    elif [ "$old_size" == "NA" ] || [ "$new_size" == "NA" ]; then
      echo -e "NA\t$key"
    ...
  \end{minted}
\end{listing}

Por fim, se os dois tamanhos existirem e não forem \Verb|NA| então calculamos a diferença entre eles e imprimimos o resultado.

\begin{listing}[H]
  \begin{minted}{bash}
    else
      diff=$((new_size - old_size))
      echo -e "$diff\t$key"
    fi
    ...
  \end{minted}
\end{listing}

\subsection{Processamento de argumentos}

Para o processamento dos argumentos usamos o comando \mintinline{bash}{getopts} com o padrão \mintinline{bash}{":hral:"}.

A opção \Verb|-h| imprime a seguinte mensagem:

\begin{listing}[H]
  \begin{minted}{bash}
    Usage: spacerate.sh [options] <new> <old>

    Options:
      -h:          Shows this message
      -r:          Print in reverse order
      -a:          Order by file name
      -l N:        Only show up to N lines
  \end{minted}
\end{listing}

Em relação ao processamento dos argumentos é feito da mesma forma que no \mintinline{bash}{spacecheck.sh} mas sem os argumentos que não se aplicam. (\ref{sec:args})

\subsection{Ordenar o output}

Ver \ref{sec:sort}

\subsection{Escolher o número de linhas}

Ver \ref{sec:head}


\section{Conclusão}

Todos os argumentos e ficheiros são validados e caso não sejam válidos é impressa uma mensagem de erro e o programa termina.

Além disso são verificados casos especiais como diretórios com um \Verb|'-'| no inicio.

\begin{listing}[H]
  \begin{minted}{bash}
    for dir in "$@"; do
      if [ ! -d "$dir" ]; then
        1>&2 echo "ERROR: \"$dir\" does not exist"
      fi
      case "$dir" in
        -*)
          if [ ! -d "$dir" ]; then
            1>&2 echo "+note: did you mean to pass an argument?"
            1>&2 echo "       all arguments must precede the directory paths"
          fi
          # Add `./` to directories beginning with a dash (`-`), so that find, doesn't
          # mistake them, for functions.
          DIRS_TO_SEARCH+=("./$dir");;
        *)
          DIRS_TO_SEARCH+=("$dir");;
      esac
    done
  \end{minted}
\end{listing}
